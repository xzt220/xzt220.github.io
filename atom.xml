<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xzt220&#39;s blog</title>
  
  <subtitle>no one knows how to pronounce</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xzt220.github.io/"/>
  <updated>2020-07-31T04:36:34.175Z</updated>
  <id>http://xzt220.github.io/</id>
  
  <author>
    <name>xzt220</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试准备</title>
    <link href="http://xzt220.github.io/2020/07/31/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://xzt220.github.io/2020/07/31/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</id>
    <published>2020-07-31T03:22:39.000Z</published>
    <updated>2020-07-31T04:36:34.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在就是很紧张，非常紧张。投了腾讯、百度（内推）都没人要，只有字节让我面试，非常害怕，非常害怕。</p><a id="more"></a><h2 id="语言相关"><a href="#语言相关" class="headerlink" title="语言相关"></a>语言相关</h2><ul><li>C++ static 作用</li><li>C++ 虚函数作用及实现</li><li>C++ 纯虚函数运行时错误的例子</li></ul><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><ul><li>剑指 offer 正则表达式匹配</li><li>数组最大值及概率</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在就是很紧张，非常紧张。投了腾讯、百度（内推）都没人要，只有字节让我面试，非常害怕，非常害怕。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试" scheme="http://xzt220.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++ auto</title>
    <link href="http://xzt220.github.io/2020/05/24/Effective-Modern-C-auto/"/>
    <id>http://xzt220.github.io/2020/05/24/Effective-Modern-C-auto/</id>
    <published>2020-05-24T13:46:52.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<p>看完觉得，能用 <code>auto</code> 就尽量用 <code>auto</code> 就对了。。。<br>以下大部分内容来自链接中的内容，加有少部分自己的理解。<br><a id="more"></a></p><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><h2 id="05-用-auto-替代显式类型声明"><a href="#05-用-auto-替代显式类型声明" class="headerlink" title="05 用 auto 替代显式类型声明"></a>05 用 auto 替代显式类型声明</h2><ul><li><code>auto</code> 声明的变量必须初始化，所以使用 <code>auto</code> 声明变量可以忘记初始化</li><li>对于名称非常长的类型，如迭代器等，用 <code>auto</code> 省力</li><li>lambda 生成的闭包类型是编译器内部的匿名类型，使用 <code>auto</code> 推断就没有这个问题</li><li>如果不使用 <code>auto</code>，可以改用 <code>std::function</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span><br><span class="line"><span class="comment">// std::function的模板参数中不能使用auto</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&amp;)&gt; f = [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span><br></pre></td></tr></table></figure></li><li>除了明显的语法冗长和不能利用 <code>auto</code> 参数的缺点，<code>std::function</code> 与 <code>auto</code> 的最大区别在于，<code>auto</code> 和闭包类型一致，内存量和闭包相同，而 <code>std::function</code> 是类模板，它的实例有一个固定大小，这个大小不一定能容纳闭包，于是会分配堆上的内存以存储闭包，导致比 <code>auto</code> 变量占用更多内存。此外，编译器一般会限制内联，<code>std::function</code> 调用闭包会比 <code>auto</code> 慢</li><li><code>auto</code> 可以避免简写类型存在的潜在问题，如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">unsigned</span> sz = v.size(); <span class="comment">// v.size()类型实际为std::vector&lt;int&gt;::size_type</span></span><br><span class="line"><span class="comment">// 在32位机器上std::vector&lt;int&gt;::size_type与unsigned尺寸相同</span></span><br><span class="line"><span class="comment">// 但在64位机器上，std::vector&lt;int&gt;::size_type是64位，而unsigned是32位</span></span><br></pre></td></tr></table></figure></li><li>下面感觉更像一个卡常的例子。。。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// m的元素类型实际是std::pair&lt;const std::string, int&gt;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; p : m) ... <span class="comment">// 类型不一致，仍要转换，期间要构造大量临时对象</span></span><br></pre></td></tr></table></figure></li><li>还有一个比较奇怪的问题，定义 lambda 闭包的时候，如果使用递归并且有返回值的话，会出现错误，如以下代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [&amp;f](<span class="keyword">int</span> n) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * f(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>上面这段代码要解决问题得使用 <code>std::function</code> 来声明类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; f = [&amp;f](<span class="keyword">int</span> n) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * f(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>还有下面这段代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = sum(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> sum(i<span class="number">-1</span>) + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>解决方案在<a href="https://stackoverflow.com/questions/43514665/use-of-auto-funcint-before-deduction-of-auto-in-c14" target="_blank" rel="noopener">这里</a>，得把定义移到 main 之前</li><li>上面两份报错的代码的报错信息都为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.cpp:8:16: error: function 'func' with deduced return type cannot be used before it is defined</span><br><span class="line">    <span class="keyword">auto</span> ret = func(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li>大概就是没定义完全之前没法使用吧。</li></ul><h2 id="06-auto推断出非预期类型时，先强制转换出预期类型"><a href="#06-auto推断出非预期类型时，先强制转换出预期类型" class="headerlink" title="06 auto推断出非预期类型时，先强制转换出预期类型"></a>06 auto推断出非预期类型时，先强制转换出预期类型</h2><ul><li>如下代码没有问题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&#123; <span class="literal">true</span>, <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> x = f()[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(x) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span>;</span><br></pre></td></tr></table></figure></li><li>但如果把显式声明改为 <code>auto</code> 则会出现非预期行为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&#123; <span class="literal">true</span>, <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = f()[<span class="number">0</span>]; <span class="comment">// 改用auto声明</span></span><br><span class="line"><span class="keyword">if</span>(x) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"OK"</span>; <span class="comment">// 错误：未定义行为</span></span><br></pre></td></tr></table></figure></li><li>原因在于实际上得到的类型不是 bool，而是<a href="https://en.cppreference.com/w/cpp/container/vector_bool/reference" target="_blank" rel="noopener">std::vector<bool>::reference</a>，这里又有一个概念是<a href="https://stackoverflow.com/questions/994488/what-is-proxy-class-in-c" target="_blank" rel="noopener">代理类</a>，个人理解它特化了某些修改操作，具体可看上面这个链接</li><li>再看下面这个例子，<code>auto</code> 也推断出了 std::vector<bool>::reference，并非我们预期的想法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v = &#123; <span class="literal">false</span>, <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> b : v) &#123;</span><br><span class="line">    b = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v = &#123; true, true &#125;</span></span><br></pre></td></tr></table></figure></li><li>如果要避免这种情况发生，事先强转类型即可或显示声明即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="literal">true</span>, <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> v = foo();</span><br><span class="line"><span class="keyword">auto</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(v[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">bool</span> y = v[<span class="number">1</span>];</span><br><span class="line">x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">bool</span> b : v) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完觉得，能用 &lt;code&gt;auto&lt;/code&gt; 就尽量用 &lt;code&gt;auto&lt;/code&gt; 就对了。。。&lt;br&gt;以下大部分内容来自链接中的内容，加有少部分自己的理解。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://xzt220.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++ 类型推断</title>
    <link href="http://xzt220.github.io/2020/05/23/Effective-Modern-C/"/>
    <id>http://xzt220.github.io/2020/05/23/Effective-Modern-C/</id>
    <published>2020-05-22T16:16:49.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<p>自从两个月前决定不打 ICPC 之后，学习效率极其低下，啥都学不进去，现在离期末还有不到一个月，但就是不想复习。所以来康康<a href="https://downdemo.gitbook.io/effective-modern-cpp/" target="_blank" rel="noopener">这本书</a>（太穷，买不起书，其实是别人的笔记？），学习一点点东西。以下大部分内容来自链接中的内容，加有少部分自己的理解。</p><a id="more"></a><h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><h2 id="01-模板类型推断机制"><a href="#01-模板类型推断机制" class="headerlink" title="01 模板类型推断机制"></a>01 模板类型推断机制</h2><ul><li>模板的形式可以看成如下伪代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType x)</span></span>;</span><br></pre></td></tr></table></figure></li><li>调用该函数可看成<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr);</span><br></pre></td></tr></table></figure></li><li><p>编译期间，编译器用 <code>expr</code> 推断 <code>T</code> 和 <code>ParamType</code>，实际上两者通常不同。</p></li><li><p><code>T</code> 的类型推断与 <code>expr</code> 和 <code>ParamType</code> 相关</p></li></ul><h3 id="情形1：ParamType-不是引用或指针"><a href="#情形1：ParamType-不是引用或指针" class="headerlink" title="情形1：ParamType 不是引用或指针"></a>情形1：ParamType 不是引用或指针</h3><ul><li>丢弃 <code>expr</code> 的 <code>top-level cv</code> 限定符和引用限定符，最后得到的 <code>expr</code> 的类型就是 <code>T</code> 和 <code>ParamType</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p2;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p3;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[] = <span class="string">"downdemo"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> s2[] = <span class="string">"downdemo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下情况T和ParamType都是int</span></span><br><span class="line">f(a);</span><br><span class="line">f(b);</span><br><span class="line">f(c);</span><br><span class="line"><span class="comment">// 指针类型丢弃的是top-level const（即指针本身的const）</span></span><br><span class="line"><span class="comment">// low-level const（即所指对象的const）会保留</span></span><br><span class="line">f(p1); <span class="comment">// T和ParamType都是int*</span></span><br><span class="line">f(p2); <span class="comment">// T和ParamType都是const int*</span></span><br><span class="line">f(p3); <span class="comment">// T和ParamType都是int*</span></span><br><span class="line">f(p4); <span class="comment">// T和ParamType都是const int*</span></span><br><span class="line"><span class="comment">// char数组会退化为指针</span></span><br><span class="line">f(s1); <span class="comment">// T和ParamType都是char*</span></span><br><span class="line">f(s2); <span class="comment">// T和ParamType都是const char*</span></span><br></pre></td></tr></table></figure></li><li>个人理解：这一类作为参数传进函数之后，是无法修改它本身的值的，比如调用 <code>f(a)</code>，其中 <code>a = 3</code>，在 <code>f</code> 中修改 <code>a</code> 是不会对实参 <code>a</code> 起到影响的，传入指针也一样，无法修改指针本身的值，但是可以修改指针所指向内容的值，这就由是否存在 <code>low-level const</code> 来指定了。</li></ul><h3 id="情形2：ParamType-是引用类型"><a href="#情形2：ParamType-是引用类型" class="headerlink" title="情形2：ParamType 是引用类型"></a>情形2：ParamType 是引用类型</h3><ul><li>当 <code>ParamType</code> 是引用类型，即<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure></li><li>保留 <code>cv</code> 限定符，<code>ParamType</code> 是左值引用类型，去掉引用限定符就是 <code>T</code> 的类型</li><li>数组类型对于 <code>T&amp;</code> 的情况比较特殊，不会退化到指针类型，例子如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] = <span class="string">"downdemo"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> s2[] = <span class="string">"downdemo"</span>;</span><br><span class="line"></span><br><span class="line">f(s1); <span class="comment">// ParamType是char(&amp;)[9]，T是char[9]</span></span><br><span class="line">f(s2); <span class="comment">// ParamType是const char(&amp;)[9]，T是const char[9]</span></span><br></pre></td></tr></table></figure></li><li>当 ParamType 是从 <code>T&amp;</code> 变成 <code>const T&amp;</code> 时，ParamType 一定是 <code>top-level const</code>，去掉 <code>top-level const</code> 和引用限定符就是 <code>T</code> 的类型，对于指针来说就是 <code>T</code> 的指针符之后一定没有 <code>const</code></li></ul><h3 id="情形3：ParamType-是指针类型"><a href="#情形3：ParamType-是指针类型" class="headerlink" title="情形3：ParamType 是指针类型"></a>情形3：ParamType 是指针类型</h3><ul><li>与情形2类似，ParamType 一定是 <code>non-const</code> 指针（传参数时忽略 <code>top-level const</code>）类型，去掉指针符就是 <code>T</code> 的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* x)</span></span>;</span><br></pre></td></tr></table></figure></li><li>如果 ParamType 带 <code>top-level const</code>，<code>T</code> 同上，不发生改变<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* <span class="keyword">const</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li><li>如果 ParamType 是 <code>pointer to const</code>，则 <code>T</code> 是不带 <code>const</code> 的非指针类型</li></ul><h3 id="情形4：ParamType-是转发引用"><a href="#情形4：ParamType-是转发引用" class="headerlink" title="情形4：ParamType 是转发引用"></a>情形4：ParamType 是转发引用</h3><p>不太懂右值引用。看了<a href="https://zhuanlan.zhihu.com/p/99524127" target="_blank" rel="noopener">这篇</a>，有点晕，以后一定好好看（</p><h3 id="特殊情形：expr-是函数名"><a href="#特殊情形：expr-是函数名" class="headerlink" title="特殊情形：expr 是函数名"></a>特殊情形：expr 是函数名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f1</span><span class="params">(T x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">f1(g); <span class="comment">// T和ParamType都是void(*)(int)</span></span><br><span class="line">f2(g); <span class="comment">// ParamType是void(&amp;)(int)，T是void()(int)</span></span><br><span class="line">f3(g); <span class="comment">// T和ParamType都是void(&amp;)(int)</span></span><br></pre></td></tr></table></figure><h2 id="02-auto"><a href="#02-auto" class="headerlink" title="02 auto"></a>02 auto</h2><ul><li>auto 类型推断几乎和模板类型推断一致</li><li>auto 推断的唯一不同于模板实参推断的情形是 C++11 的初始化列表，下面是同样的初始化功能<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">int</span> x1 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">int</span> x3 = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> x4&#123; <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure></li><li>但换成 auto 声明，这些赋值的意义就不同了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">1</span>; <span class="comment">// int x1</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// int x2</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">1</span> &#125;; <span class="comment">// std::initializer_list&lt;int&gt; x3</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">1</span> &#125;; <span class="comment">// C++11为std::initializer_list&lt;int&gt; x4，C++14为int x4</span></span><br></pre></td></tr></table></figure></li><li><blockquote><p>C++14 禁止对 auto 用std::initializer_list直接初始化，而必须用 =，除非列表中只有一个元素，这时不会将其视为std::initializer_list</p></blockquote></li><li>以上为原文，本地测试了一下 Linux/Windows 的 <code>g++ *.cpp -o * -std=c++11</code> 和 <code>g++ *.cpp -o * -std=c++14</code> 编译一下代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> x1 &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(x1).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出均为 <code>i</code>，即 <code>int</code> 类型</li><li>模板不支持模板参数为 <code>T</code> 而 <code>expr</code> 为初始化列表的推断，这就是 auto 推断和模板推断唯一的不同之处<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 等价于x声明的模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T x)</span></span>;</span><br><span class="line"></span><br><span class="line">foo(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// 错误：不能推断T的类型</span></span><br></pre></td></tr></table></figure><h3 id="C-14中的-auto"><a href="#C-14中的-auto" class="headerlink" title="C++14中的 auto"></a>C++14中的 auto</h3></li><li>C++14 中 auto 可以作为函数返回类型，并且 lambda 可以将参数声明为 auto，即泛型 lambda<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">auto</span> g = [](<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></li><li>但这里的 auto 推断仍然是模板实参推断的机制，因此不能返回一个初始化列表，即使为单元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>&#125; &#125;; <span class="comment">// error: returning initializer list</span></span><br></pre></td></tr></table></figure></li><li>泛型 lambda 同理<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> resetV = [&amp;v](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; newValue) &#123; v = newValue; &#125;;</span><br><span class="line">resetV(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="C-17-中的-auto"><a href="#C-17-中的-auto" class="headerlink" title="C++17 中的 auto"></a>C++17 中的 auto</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X&lt;<span class="number">1</span>&gt; x;</span><br><span class="line">x.f(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="03-decltype"><a href="#03-decltype" class="headerlink" title="03 decltype"></a>03 decltype</h2><ul><li><code>decltype</code> 会推断出直觉预期的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// decltype(x) 为 const int</span></span><br></pre></td></tr></table></figure></li><li>decltype 一般用来声明与参数类型相关的返回类型。比如下面模板的参数是容器和索引，而返回类型取决于元素类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line">auto f(Container&amp; c, Index i) -&gt; decltype(c[i]) &#123; // auto不做任何事，只是表示使用类型推断，推断使用的是decltype</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>C++14 允许省略尾置返回类型，只留下 <code>auto</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(Container&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>但以下情况会出错<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">f(v, <span class="number">0</span>) = <span class="number">4</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><code>auto</code> 将返回值推断为 <code>int</code> 而非 <code>int &amp;</code></li><li>为了得到期望的返回类型，需要对返回类型使用 <code>decltype</code> 的推断机制，C++14 允许将返回类型声明为 <code>decltype(auto)</code> 来实现这点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f</span><span class="params">(Container&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>decltype(auto)</code> 也可以作为变量声明类型</li><li>还有一部分是转发引用等等的问题，留坑。。。</li><li>一些特殊情况<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p; <span class="comment">// decltype(*p)是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a=<span class="number">1</span>) c = b; <span class="comment">// int&amp;</span></span><br><span class="line">c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c; <span class="comment">// 033</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">// decltype((i))是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// decltype(x)是int，因此返回int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">return</span> (x); <span class="comment">// decltype((x))是int&amp;，因此返回了局部变量的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="04-查看推断类型的方法"><a href="#04-查看推断类型的方法" class="headerlink" title="04 查看推断类型的方法"></a>04 查看推断类型的方法</h2><ul><li>IDE 查看</li><li>利用报错信息，比如写一个声明但不定义的类模板，用这个模板创建实例时将出错，编译将提示错误原因<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line">A&lt;<span class="keyword">decltype</span>(x)&gt; xType; <span class="comment">// 未定义类模板，错误信息将提示x类型</span></span><br><span class="line"><span class="comment">// 比如对int x报错如下</span></span><br><span class="line">error C2079: “xType”使用未定义的 <span class="class"><span class="keyword">class</span>“<span class="title">A</span>&lt;int&gt;”</span></span><br></pre></td></tr></table></figure></li><li>使用type_id运算符和std::type_info::name获取类型，但得到的类型会忽略cv和引用限定符<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"T = "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x = "</span> &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用Boost.TypeIndex可以得到精确类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"T = "</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x = "</span> &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(x)&gt;().pretty_name() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从两个月前决定不打 ICPC 之后，学习效率极其低下，啥都学不进去，现在离期末还有不到一个月，但就是不想复习。所以来康康&lt;a href=&quot;https://downdemo.gitbook.io/effective-modern-cpp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这本书&lt;/a&gt;（太穷，买不起书，其实是别人的笔记？），学习一点点东西。以下大部分内容来自链接中的内容，加有少部分自己的理解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://xzt220.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Tinkoff Internship Warmup Round 2018 and Codeforces Round #475 (Div. 1)</title>
    <link href="http://xzt220.github.io/2019/10/04/Tinkoff-Internship-Warmup-Round-2018-and-Codeforces-Round-475-Div-1/"/>
    <id>http://xzt220.github.io/2019/10/04/Tinkoff-Internship-Warmup-Round-2018-and-Codeforces-Round-475-Div-1/</id>
    <published>2019-10-04T13:07:57.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Alternating-Sum"><a href="#A-Alternating-Sum" class="headerlink" title="A. Alternating Sum"></a>A. Alternating Sum</h2><a id="more"></a><p>就是个等比数列，特判公比为 $1$ 的情况即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = MOD - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = <span class="number">1L</span>L * ans * a % MOD;</span><br><span class="line">a = <span class="number">1L</span>L * a * a % MOD;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += MOD;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= MOD) a -= MOD;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, a, b, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;k);</span><br><span class="line"><span class="keyword">int</span> q = <span class="number">1L</span>L * qp(qp(a, k)) * qp(b, k) % MOD;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = ((s[i] == <span class="string">'+'</span>) ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">a1 = M(a1 + <span class="number">1L</span>L * x * qp(a, n - i) % MOD * qp(b, i) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1L</span>L * a1 * (n + <span class="number">1</span>) / k % MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> inv = qp(q - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1L</span>L * a1 * (qp(q, (n + <span class="number">1</span>) / k) - <span class="number">1</span>) % MOD * inv % MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Destruction-of-a-Tree"><a href="#B-Destruction-of-a-Tree" class="headerlink" title="B. Destruction of a Tree"></a>B. Destruction of a Tree</h2><p>优先删除靠近叶子节点的偶数度数的节点，因为假如删了这个节点的父节点，就剩下两个点一条边了。<br>那这样肯定是不能删完的。<br>就搞出dfs序，倒着删，如果有偶数度数的就往下删，不往父节点方向走即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> degree[N], fa[N], dfn[N], tol;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> ans[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">fa[u] = pre;</span><br><span class="line">dfn[++tol] = u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u])</span><br><span class="line"><span class="keyword">if</span> (v != pre)</span><br><span class="line">dfs(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">ans[++cnt] = u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) &#123;</span><br><span class="line">degree[v]--;</span><br><span class="line"><span class="keyword">if</span> (v == fa[u] || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (degree[v] % <span class="number">2</span> == <span class="number">0</span>) dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">continue</span>;</span><br><span class="line">degree[i]++;</span><br><span class="line">degree[x]++;</span><br><span class="line">G[i].push_back(x);</span><br><span class="line">G[x].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tol; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (degree[dfn[i]] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">dfs2(dfn[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Cutting-Rectangle"><a href="#C-Cutting-Rectangle" class="headerlink" title="C. Cutting Rectangle"></a>C. Cutting Rectangle</h2><p>画图发现，对于不一样长度的矩形，它所具有的宽度集合必须一样，并且对应的 $c$ 个数必须成比例。<br>排个序排除一下这两种情况。<br>具体排列方式就与比例的约数有关了，比如对于长为 $3$ 的矩形，它具有的宽度集合为 $2$，$3$，$4$，个数分别为 $2$，$4$，$6$<br>那么基底就为 $1$ $2$ $3$，把它们拼在一起，就有两个这样的大矩形，那么排列方式就是两种，横着拼一起或者竖着拼一起。<br>也就是 gcd 的约数个数，但这只是一组的排列方式，因为要满足和其它组能拼成最后的大矩形，那么就是所有数的 gcd 的约数个数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">ll w, h, c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;w, &amp;h, &amp;c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> P &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w &lt; rhs.w || (w == rhs.w &amp;&amp; h &lt; rhs.h);</span><br><span class="line">&#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; vec[N];</span><br><span class="line">ll base[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">gcd</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span></span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line">a %= b;</span><br><span class="line">swap(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">p[i].read();</span><br><span class="line">sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i].w != p[i - <span class="number">1</span>].w) cnt++;</span><br><span class="line">vec[cnt].push_back(pii(p[i].h, p[i].c));</span><br><span class="line">&#125;</span><br><span class="line">ll g = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p: vec[<span class="number">1</span>]) </span><br><span class="line">g = gcd(g, p.se);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec[<span class="number">1</span>].size(); i++)</span><br><span class="line">base[i] = vec[<span class="number">1</span>][i].se / g;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=cnt &amp;&amp; !flag; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vec[i].size() != vec[i - <span class="number">1</span>].size()) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vec[i][j].fi != vec[i - <span class="number">1</span>][j].fi) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (vec[i][<span class="number">0</span>].se % base[<span class="number">0</span>]) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll temp = vec[i][<span class="number">0</span>].se / base[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; vec[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vec[i][j].se / base[j] != temp) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">g = gcd(g, vec[i][<span class="number">0</span>].se / base[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i * i &lt;= g; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g % i) <span class="keyword">continue</span>;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">if</span> (g / i != i) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Frequency-of-String"><a href="#D-Frequency-of-String" class="headerlink" title="D. Frequency of String"></a>D. Frequency of String</h2><p>AC自动机直接做。或者哈希。<br>对长度相同的串同时查询，长度不同的串不超过 $\sqrt n$ 种。这样查询的复杂度是 $O(n \sqrt n)$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Aho</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> trie[N][sz], tol, fail[N], pos[N], last[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tol = <span class="number">0</span>;</span><br><span class="line">newnode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) trie[tol][i] = <span class="number">0</span>;</span><br><span class="line">fail[tol] = pos[tol] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (!trie[u][id]) trie[u][id] = newnode();</span><br><span class="line">u = trie[u][id];</span><br><span class="line">&#125;</span><br><span class="line">pos[u] = index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) </span><br><span class="line"><span class="keyword">if</span> (trie[<span class="number">0</span>][i]) que.push(trie[<span class="number">0</span>][i]);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;v = trie[u][i];</span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">fail[v] = trie[fail[u]][i];</span><br><span class="line">que.push(v);</span><br><span class="line">last[v] = pos[fail[v]] ? fail[v] : last[fail[v]];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v = trie[fail[u]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> temp = trie[u][id];</span><br><span class="line">u = temp;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="keyword">if</span> (pos[temp]) vec[pos[temp]].push_back(i);</span><br><span class="line">temp = last[temp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ac; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">int</span> k[N], len[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, s, &amp;n);</span><br><span class="line">ac.init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, k + i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">ac.ins(t, i);</span><br><span class="line">len[i] = <span class="built_in">strlen</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">ac.build();</span><br><span class="line">ac.search(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vec[i].size() &lt; k[i]) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = k[i] - <span class="number">1</span>; r &lt; vec[i].size(); l++, r++) &#123;</span><br><span class="line">ans = min(ans, vec[i][r] + len[i] - <span class="number">1</span> - vec[i][l] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ull BASE = <span class="number">201326611</span>;</span><br><span class="line">ull bit[N], Hash[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ull, <span class="keyword">int</span>&gt; id[N];</span><br><span class="line"><span class="keyword">int</span> vec[N], cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Hash[r] - Hash[l - <span class="number">1</span>] * bit[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">int</span> k[N], l[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bit[<span class="number">0</span>] = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">bit[i] = bit[i - <span class="number">1</span>] * BASE, Hash[i] = Hash[i - <span class="number">1</span>] * BASE + s[i];</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, k + i, t + <span class="number">1</span>);</span><br><span class="line">l[i] = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">ull temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l[i]; j++)</span><br><span class="line">temp = temp * BASE + t[j];</span><br><span class="line">id[l[i]][temp] = i;</span><br><span class="line">vec[++cnt] = l[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(vec + <span class="number">1</span>, vec + <span class="number">1</span> + cnt);</span><br><span class="line">cnt = unique(vec + <span class="number">1</span>, vec + <span class="number">1</span> + cnt) - vec - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = vec[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ll = <span class="number">1</span>, rr = n; rr &lt;= len; ll++, rr++) &#123;</span><br><span class="line">ull temp = get(ll, rr);</span><br><span class="line"><span class="keyword">if</span> (id[n].count(temp))</span><br><span class="line">pos[id[n][temp]].push_back(ll);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ll = <span class="number">0</span>, rr = k[i] - <span class="number">1</span>; rr &lt; pos[i].size(); ll++, rr++)</span><br><span class="line">ans = min(ans, pos[i][rr] + l[i] - <span class="number">1</span> - pos[i][ll] + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans == <span class="number">1e9</span>) ? <span class="number">-1</span> : ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Circles-of-Waiting"><a href="#E-Circles-of-Waiting" class="headerlink" title="E. Circles of Waiting"></a>E. Circles of Waiting</h2><p>有转移方程 <script type="math/tex">f(x, y) = p_1 * f(x - 1, y) + p_2 * f(x, y - 1) + p_3 * f(x + 1, y) + p_4 * f(x, y + 1) + 1</script><br>有 $R ^ 2$ 个未知数，直接高斯消元解复杂度为 $O(R ^ 6)$<br>因为跟自己有关的项达不到 $R^2$ 的级别。所以只要对相邻这些消元即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7850</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[<span class="number">4</span>], ans[M], a[M][M];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = MOD - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = <span class="number">1L</span>L * ans * a % MOD;</span><br><span class="line">a = <span class="number">1L</span>L * a * a % MOD;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> R;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;R);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i), sum += p[i];</span><br><span class="line">sum = qp(sum);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">p[i] = <span class="number">1L</span>L * p[i] * sum % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -R; i &lt;= R; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -R; j &lt;= R; j++)</span><br><span class="line"><span class="keyword">if</span> (i * i + j * j &lt;= R * R)</span><br><span class="line">all.push_back(pii(i, j));</span><br><span class="line">n = all.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = all[i].fi, y = all[i].se;</span><br><span class="line">a[i][i] = a[i][n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = x + dx[j], v = y + dy[j];</span><br><span class="line"><span class="keyword">if</span> (u * u + v * v &lt;= R * R) </span><br><span class="line">a[i][lower_bound(all.begin(), all.end(), pii(u, v)) - all.begin()] = MOD - p[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = &#123;n&#125;;</span><br><span class="line"><span class="keyword">int</span> u = min(i + R * <span class="number">2</span> + <span class="number">5</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; u; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">t.push_back(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> inv = qp(a[i][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; u; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line"><span class="keyword">int</span> mul = <span class="number">1L</span>L * a[j][i] * inv % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> k: t) &#123;</span><br><span class="line">a[j][k] = (a[j][k] - <span class="number">1L</span>L * mul * a[i][k] % MOD + MOD) % MOD; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> val = a[i][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">val = (val - <span class="number">1L</span>L * ans[j] * a[i][j] % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">ans[i] = <span class="number">1L</span>L * val * qp(a[i][i]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[lower_bound(all.begin(), all.end(), pii(<span class="number">0</span>, <span class="number">0</span>)) - all.begin()]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-Alternating-Sum&quot;&gt;&lt;a href=&quot;#A-Alternating-Sum&quot; class=&quot;headerlink&quot; title=&quot;A. Alternating Sum&quot;&gt;&lt;/a&gt;A. Alternating Sum&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Codeforces" scheme="http://xzt220.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 47 (Rated for Div. 2) G. Allowed Letters</title>
    <link href="http://xzt220.github.io/2019/10/03/Educational-Codeforces-Round-47-Rated-for-Div-2-G-Allowed-Letters/"/>
    <id>http://xzt220.github.io/2019/10/03/Educational-Codeforces-Round-47-Rated-for-Div-2-G-Allowed-Letters/</id>
    <published>2019-10-03T02:00:21.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="G-Allowed-Letters"><a href="#G-Allowed-Letters" class="headerlink" title="G. Allowed Letters"></a><center>G. Allowed Letters</center></h1><center>time limit per test: 2 seconds</center><center>memory limit per test: 256 megabytes</center><center>input: standard input</center><center>output: standard output</center><p>Polycarp has just launched his new startup idea. The niche is pretty free and the key vector of development sounds really promising, so he easily found himself some investors ready to sponsor the company. However, he is yet to name the startup!</p><p>Actually, Polycarp has already came up with the name but some improvement to it will never hurt. So now he wants to swap letters at some positions in it to obtain the better name. It isn’t necessary for letters to be adjacent.</p><p>In addition, each of the investors has chosen some index in the name and selected a set of letters that can go there. Indices chosen by different investors are pairwise distinct. If some indices aren’t chosen by any investor then any letter can go there.</p><p>Finally, Polycarp is sure that the smallest lexicographically name is the best. (Like why do you think Google decided to become Alphabet?)</p><p>More formally, you are given a string consisting of lowercase Latin letters from “a” to “f”. You can swap letters at any positions arbitrary number of times (zero swaps is also possible).</p><p>What is the smallest lexicographically name you can obtain such that the letter at every position is among the allowed letters?</p><p>If Polycarp can’t produce any valid name then print “Impossible”.<br><a id="more"></a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line is the string $s$ ($1\leq|s|\leq 10^5$) — the name Polycarp has came up with. The string consists only of lowercase Latin letters from “a” to “f”.</p><p>The second line contains a single integer $m$ ($0\leq m \leq |s|$) — the number of investors.</p><p>The $i$-th of the next $m$ lines contain an integer number $pos_i$ and a non-empty string of allowed characters for $pos_i$ ($1\leq pos_i \leq |s|$). Each string contains pairwise distinct letters from “a” to “f”. $pos_1,pos_2,\dots,pos_m$ are pairwise distinct. If any position of the string doesn’t appear in the investors demands then any letter can go in this position.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>If Polycarp can’t produce any valid name then print “Impossible”.</p><p>Otherwise print the smallest lexicographically name Polycarp can obtain by swapping letters in string s such that the letter at every position is among the allowed ones.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>bedefead<br>5<br>2 e<br>1 dc<br>5 b<br>7 ef<br>6 ef</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>deadbeef</p><h3 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h3><p>abacaba<br>0</p><h3 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h3><p>aaaabbc</p><h3 id="input-2"><a href="#input-2" class="headerlink" title="input"></a>input</h3><p>fc<br>2<br>1 cfab<br>2 f</p><h3 id="output-2"><a href="#output-2" class="headerlink" title="output"></a>output</h3><p>cf</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>把原字符看成 $X$，每个位置看成 $Y$，每种字符向每个能去的位置连边，就成了一个二分图完美匹配的问题。<br>现要得到字典序最小，那么就枚举每一位要放什么，然后看放完这种字符，剩下的字符的个数和后面能不能形成完美匹配。<br>根据霍尔定理，选择 $X$ 中的一个子集 $s$，和 $Y$ 连边的点集为 $N(s)$，那么 $N(s)$ 的大小就只和 $s$ 中的字符种类数有关。<br>当 $s$ 最大时肯定是每种字符的个数都拿上。那么就用一个 $cnt[i][s]$ 表示后缀 $[i, n]$ 中和 $s$ 连边的位置数。<br>然后枚举一下子集再判断一下 $N(s)$ 和 $s$ 的关系就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N][<span class="number">1</span> &lt;&lt; <span class="number">6</span>], cnt2[<span class="number">6</span>], bin[N];</span><br><span class="line"><span class="keyword">char</span> s[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cnt2[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">10</span>]; <span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;x, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j]; j++)</span><br><span class="line">bin[x] |= (<span class="number">1</span> &lt;&lt; (t[j] - <span class="string">'a'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (bin[i] == <span class="number">0</span>) bin[i] = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); s++) &#123;</span><br><span class="line">cnt[i][s] = cnt[i + <span class="number">1</span>][s];</span><br><span class="line"><span class="keyword">if</span> (bin[i] &amp; s) cnt[i][s]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> alp = <span class="number">0</span>; alp &lt; <span class="number">6</span>; alp++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt2[alp] || (bin[i] &gt;&gt; alp &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">cnt2[alp]--;</span><br><span class="line"><span class="keyword">bool</span> check = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); s++) &#123;</span><br><span class="line"><span class="keyword">int</span> cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) <span class="keyword">if</span> (s &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">cn += cnt2[j];</span><br><span class="line"><span class="keyword">if</span> (cn &gt; cnt[i + <span class="number">1</span>][s]) &#123;</span><br><span class="line">check = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check) &#123;</span><br><span class="line">ans[i] = (<span class="keyword">char</span>)(alp + <span class="string">'a'</span>);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt2[alp]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(ans + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;G-Allowed-Letters&quot;&gt;&lt;a href=&quot;#G-Allowed-Letters&quot; class=&quot;headerlink&quot; title=&quot;G. Allowed Letters&quot;&gt;&lt;/a&gt;&lt;center&gt;G. Allowed Letters&lt;/center&gt;&lt;/h1&gt;&lt;center&gt;time limit per test: 2 seconds&lt;/center&gt;
&lt;center&gt;memory limit per test: 256 megabytes&lt;/center&gt;
&lt;center&gt;input: standard input&lt;/center&gt;
&lt;center&gt;output: standard output&lt;/center&gt;

&lt;p&gt;Polycarp has just launched his new startup idea. The niche is pretty free and the key vector of development sounds really promising, so he easily found himself some investors ready to sponsor the company. However, he is yet to name the startup!&lt;/p&gt;
&lt;p&gt;Actually, Polycarp has already came up with the name but some improvement to it will never hurt. So now he wants to swap letters at some positions in it to obtain the better name. It isn’t necessary for letters to be adjacent.&lt;/p&gt;
&lt;p&gt;In addition, each of the investors has chosen some index in the name and selected a set of letters that can go there. Indices chosen by different investors are pairwise distinct. If some indices aren’t chosen by any investor then any letter can go there.&lt;/p&gt;
&lt;p&gt;Finally, Polycarp is sure that the smallest lexicographically name is the best. (Like why do you think Google decided to become Alphabet?)&lt;/p&gt;
&lt;p&gt;More formally, you are given a string consisting of lowercase Latin letters from “a” to “f”. You can swap letters at any positions arbitrary number of times (zero swaps is also possible).&lt;/p&gt;
&lt;p&gt;What is the smallest lexicographically name you can obtain such that the letter at every position is among the allowed letters?&lt;/p&gt;
&lt;p&gt;If Polycarp can’t produce any valid name then print “Impossible”.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Hall定理" scheme="http://xzt220.github.io/tags/Hall%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Loj #6062. 「2017 山东一轮集训 Day2」Pair</title>
    <link href="http://xzt220.github.io/2019/10/03/Loj-6062-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-Day2%E3%80%8DPair/"/>
    <id>http://xzt220.github.io/2019/10/03/Loj-6062-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-Day2%E3%80%8DPair/</id>
    <published>2019-10-03T01:24:52.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个长度为 $n$ 的数列 {$a_i$} 和一个长度为 $m$ 的数列 {$b_i$}，求 {$a_i$} 有多少个长度为 $m$ 的连续子数列能与  匹配。</p><p>两个数列可以匹配，当且仅当存在一种方案，使两个数列中的数可以两两配对，两个数可以配对当且仅当它们的和不小于 $h$。</p><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个数字 $n$, $m$, $h$。<br>第二行有 $m$ 个数字 $b_1, b_2, \dots, b_m$。<br>第三行有 $n$ 个数字 $a_1, a_2, \dots, a_n$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个数字，{$a_i$} 有多少个长度为 $m$ 的连续子数列能与 {$b_i$} 匹配。</p><h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$1 \leq m \leq n \leq 150000$<br>$1 \leq a_i, b_i, h \leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>数据小的话就暴力跑网络流就好了。<br>但是这里是 $10^5$ 就不行了。<br>现在枚举 {$a_i$} 中一段长为 $m$ 的连续子序列，考虑和 {$b_i$} 中的完美匹配。<br>根据Hall定理，一个二分图，分为 $X$ 和 $Y$，存在完美匹配的充要条件为<br>任取 $X$ 中一个子集 $s$，$Y$ 中与 $s$ 连边的点集记为 $N(s)$，则 $|s| \leq |N(s)|$ ($|s|$ 表示集合 $s$ 的大小)<br>若 存在这个题里面，一个集合 $s$ 里，与另一个集合能连边形成的 $N(s)$，只与 $s$ 里的最大值有关。<br>因为 $x + y \geq h$，$z \geq x$，肯定有 $z + y \geq h$<br>那么我们取的 $X$ 就为 {$b_i$} 咯。因为 {$b_i$} 没有顺序的影响，那么先从大到小排序。<br>当前枚举的子集的最大值就 $b_i$，那么 $N(s)$ 的大小就确定下来了。<br>再看看 $s$ 大小最大(在 $b_i$ 为子集的最大值时)为 $i$，那么就是 $N(s) \geq i$。<br>对于 {$a_i$} 中每一个元素能跟 {$b_i$} 匹配的一段是一段后缀。<br>那么用线段树维护 {$b_i$} 与 {$a_i$} 的匹配数减去 $i$，看区间最小值是否不小于 $0$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rp p &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">int</span> tree[N * <span class="number">4</span>], lazy[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tree[p] = -l;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lp, l, mid);</span><br><span class="line">build(rp, mid + <span class="number">1</span>, r);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tree[p] = min(tree[lp], tree[rp]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tag</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">tree[p] += val;</span><br><span class="line">lazy[p] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">tag(lp, lazy[p]);</span><br><span class="line">tag(rp, lazy[p]);</span><br><span class="line">lazy[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) &#123;</span><br><span class="line">tree[p] += val;</span><br><span class="line">lazy[p] += val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update(lp, l, mid, x, y, val);</span><br><span class="line"><span class="keyword">if</span> (y &gt; mid) update(rp, mid + <span class="number">1</span>, r, x, y, val);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, h;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;h);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">seg.build(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">sort(b + <span class="number">1</span>, b + <span class="number">1</span> + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + m, h - a[i]) - b;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= m) seg.update(<span class="number">1</span>, <span class="number">1</span>, m, j, m, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + m, h - a[i]) - b;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= m) seg.update(<span class="number">1</span>, <span class="number">1</span>, m, j, m, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (seg.tree[<span class="number">1</span>] &gt;= <span class="number">0</span>) ans++;</span><br><span class="line">j = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + m, h - a[i - m + <span class="number">1</span>]) - b;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= m) seg.update(<span class="number">1</span>, <span class="number">1</span>, m, j, m, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出一个长度为 $n$ 的数列 {$a_i$} 和一个长度为 $m$ 的数列 {$b_i$}，求 {$a_i$} 有多少个长度为 $m$ 的连续子数列能与  匹配。&lt;/p&gt;
&lt;p&gt;两个数列可以匹配，当且仅当存在一种方案，使两个数列中的数可以两两配对，两个数可以配对当且仅当它们的和不小于 $h$。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="线段树" scheme="http://xzt220.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="Hall定理" scheme="http://xzt220.github.io/tags/Hall%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Avito Code Challenge 2018</title>
    <link href="http://xzt220.github.io/2019/10/02/Avito-Code-Challenge-2018/"/>
    <id>http://xzt220.github.io/2019/10/02/Avito-Code-Challenge-2018/</id>
    <published>2019-10-01T18:27:33.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Antipalindrome"><a href="#A-Antipalindrome" class="headerlink" title="A. Antipalindrome"></a>A. Antipalindrome</h2><p>直接暴力判断就行了。<br><a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">i++; j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tail = n - <span class="number">1</span>; tail &gt;= <span class="number">0</span>; tail--) &#123;</span><br><span class="line"><span class="keyword">if</span> (!check(<span class="number">0</span>, tail)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tail + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Businessmen-Problems"><a href="#B-Businessmen-Problems" class="headerlink" title="B. Businessmen Problems"></a>B. Businessmen Problems</h2><p>排序或者map都行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">mp[x] = y;</span><br><span class="line">ans += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (mp.count(x)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[x] &lt; y) ans += y - mp[x];</span><br><span class="line">&#125; <span class="keyword">else</span> ans += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Useful-Decomposition"><a href="#C-Useful-Decomposition" class="headerlink" title="C. Useful Decomposition"></a>C. Useful Decomposition</h2><p>如果整棵树没有一个节点度数大于 $2$，那么显然这棵树就是一条链，输出两个度数为 $1$ 的节点即可。<br>存在度数大于 $2$ 的，那么这个节点就是那个分解点，看有多少个度数大于等于 $3$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (G[i].size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ans) &#123;</span><br><span class="line">ans = i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (G[i].size() == <span class="number">1</span>) &#123;</span><br><span class="line">ends.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">if</span> (!ans) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n%d %d\n"</span>, ends[<span class="number">0</span>], ends[<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)ends.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v: ends) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Bookshelves"><a href="#D-Bookshelves" class="headerlink" title="D. Bookshelves"></a>D. Bookshelves</h2><p>这是第二次见位运算参与的DP了。<br>位运算不满足最优子结构的性质，当前是max，不一定后面用到这个值能使答案更大。<br>那么考虑按位贪心，位越高为 $1$ 肯定越优。<br>那么从高到低枚举每一位能否为 $1$，再用DP check一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[N][N];</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll ans)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++)</span><br><span class="line"><span class="keyword">if</span> (((sum[i] - sum[k - <span class="number">1</span>] &amp; ans) == ans) &amp;&amp; dp[k - <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sum[i]), sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">58</span>; ~i; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (check(ans | (<span class="number">1L</span>L &lt;&lt; i)))</span><br><span class="line">ans |= (<span class="number">1L</span>L &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Addition-on-Segments"><a href="#E-Addition-on-Segments" class="headerlink" title="E. Addition on Segments"></a>E. Addition on Segments</h2><p>写了一个可撤销的DP。没有意识到会爆long long。WA在75。<br>一看题解发现加个不容易被卡的模数可行。还真过了。板子里面得备一些奇奇怪怪的模数了。</p><p>最开始写的很暴力。扫描线，遇到一个 $l$ 当前multiset就插入这个 $x$，遇到一个 $r$ 就删除。<br>如果当前位置的值都处理完了，multiset不为空，就做一遍DP，用bitset优化一下，但是显然复杂度能卡到 $O(\dfrac{n ^ 3}{32})$</p><p>然后就想到每次都没必要初始化背包，加入一个数就直接加，删除就直接删，也就是正着做减法背包。<br>复杂度 $O(nq)$。但就是爆long long。加个模数就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">402653189</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; mask, temp;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; p[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= MOD) x -= MOD;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l, r, x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">p[l].push_back(pii(x, <span class="number">1</span>));</span><br><span class="line">p[r + <span class="number">1</span>].push_back(pii(x, <span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> u: p[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (u.se == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = u.fi; i &lt;= n; i++) &#123;</span><br><span class="line">M(dp[i] -= dp[i - u.fi]);</span><br><span class="line"><span class="keyword">if</span> (dp[i]) temp.<span class="built_in">set</span>(i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> temp.<span class="built_in">set</span>(i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= u.fi; i--) &#123;</span><br><span class="line">M(dp[i] += dp[i - u.fi]);</span><br><span class="line"><span class="keyword">if</span> (dp[i]) temp.<span class="built_in">set</span>(i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> temp.<span class="built_in">set</span>(i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mask |= temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (mask.test(i)) ans.push_back(i);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">cnt = ans.size();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x: ans) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%c"</span>, x, <span class="string">" \n"</span>[cnt == <span class="number">1</span>]);</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质就是维护每个节点的数形成的背包长啥样。长啥样具体可以用bitset表示。<br>那么就用线段树维护bitset。下放标记就行了。<br>复杂度 $O(\dfrac{nqlogn}{32})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rp p &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; tree[N * <span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lazy[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> * N; i++)</span><br><span class="line">tree[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) &#123;</span><br><span class="line">lazy[p].push_back(v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update(lp, l, mid, x, y, v);</span><br><span class="line"><span class="keyword">if</span> (y &gt; mid) update(rp, mid + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tree[lp] |= tree[p];</span><br><span class="line">tree[rp] |= tree[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x: lazy[p]) &#123;</span><br><span class="line">tree[p] |= (tree[p] &lt;&lt; x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">ans |= tree[p];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lp, l, mid);</span><br><span class="line">build(rp, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">seg.init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l, r, x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">seg.update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line">&#125;</span><br><span class="line">seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (ans.test(i)) cnt++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (ans.test(i)) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Round-Marriage"><a href="#F-Round-Marriage" class="headerlink" title="F. Round Marriage"></a>F. Round Marriage</h2><p>二分答案。<br>环上距离表示为 $min(|a<em>i - b_j|, L - |a_i - b_j|)$。<br>拆绝对值就发现只多了 $b_j + L$， $b_j - L$ 这两项。<br>那么加入到 $b$ 数组里面就可以破环成链了。<br>把 $a$ $b$ 数组排序<br>如果 $a_1$ 选了 $b_j$，那么接下来肯定是 $a_2$ 选 $b</em>{j+1}$ 依次下去肯定是最优的。<br>所以就看每个 $a_i$ 能在 $b$ 匹配的区间中，能否每个区间取一个数形成一个等差数列。<br>一种实现方式是对于每一个 $a_i$ 能交的区间 $[l, r]$，左右端点减去 $i$ 变成 $[l - i, r - i]$。就变成了求有没有起点相同。<br>直接求区间交就可以了。<br>这个贪心是最优的但不是充要的。<br>第一个数求到了 $[l, r]$，那么第二个数从 $[l + 1, r + 1]$ 里面找一个合法的区间，这样继续找，只要最后一个数能找的区间存在，那么就是可以的。<br>双指针扫就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], b[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">3</span> * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (a[i] - b[l] &gt; x) l++;</span><br><span class="line"><span class="keyword">while</span> (b[r] - a[i] &gt; x) r--;</span><br><span class="line">l++; r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l &lt;= r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> L;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;L);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, b + i), b[n + i] = b[i] + L, b[<span class="number">2</span> * n + i] = b[i] - L;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">sort(b + <span class="number">1</span>, b + <span class="number">1</span> + <span class="number">3</span> * n);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = L, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Magic-multisets"><a href="#G-Magic-multisets" class="headerlink" title="G. Magic multisets"></a>G. Magic multisets</h2><p>首先对整个区间都乘上 $2$，再对那些没有这个数的乘上 $2$ 的逆元再加 $1$。<br>第二个步骤是关键。<br>开 $N$ 个 set，对于每个数 $x$ 的set存一些区间，表示这些区间里都有这个数 $x$。<br>每次更新操作的区间 $[l, r]$，就相当于把这个set里面与 $[l, r]$ 相交的区间都合并起来。<br>意会一下感觉总的合并次数最多只有 $n$ 次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = (MOD + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= MOD ? x - MOD : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rp p &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">int</span> tree[N * <span class="number">4</span>], mul[N * <span class="number">4</span>], add[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">mul[p] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lp, l, mid);</span><br><span class="line">build(rp, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tree[p] = M(tree[lp] + tree[rp]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tagm</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">mul[p] = <span class="number">1L</span>L * mul[p] * val % MOD;</span><br><span class="line">add[p] = <span class="number">1L</span>L * add[p] * val % MOD;</span><br><span class="line">tree[p] = <span class="number">1L</span>L * tree[p] * val % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">taga</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">add[p] = M(add[p] + val);</span><br><span class="line">tree[p] = M(tree[p] + <span class="number">1L</span>L * cnt * val % MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> llen, <span class="keyword">int</span> rlen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mul[p] != <span class="number">1</span>) &#123;</span><br><span class="line">tagm(lp, mul[p]);</span><br><span class="line">tagm(rp, mul[p]);</span><br><span class="line">mul[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (add[p]) &#123;</span><br><span class="line">taga(lp, add[p], llen);</span><br><span class="line">taga(rp, add[p], rlen);</span><br><span class="line">add[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_M</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) &#123;</span><br><span class="line">tree[p] = <span class="number">1L</span>L * tree[p] * val % MOD;</span><br><span class="line">mul[p] = <span class="number">1L</span>L * mul[p] * val % MOD;</span><br><span class="line">add[p] = <span class="number">1L</span>L * add[p] * val % MOD;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushdown(p, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update_M(lp, l, mid, x, y, val);</span><br><span class="line"><span class="keyword">if</span> (y &gt; mid) update_M(rp, mid + <span class="number">1</span>, r, x, y, val);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_A</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) &#123;</span><br><span class="line">tree[p] = M(tree[p] + <span class="number">1L</span>L * (r - l + <span class="number">1</span>) * val % MOD);</span><br><span class="line">add[p] = M(add[p] + val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushdown(p, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update_A(lp, l, mid, x, y, val);</span><br><span class="line"><span class="keyword">if</span> (y &gt; mid) update_A(rp, mid + <span class="number">1</span>, r, x, y, val);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">pushdown(p, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) ans = M(ans + query(lp, l, mid, x, y));</span><br><span class="line"><span class="keyword">if</span> (y &gt; mid) ans = M(ans + query(rp, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;pii&gt; st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">seg.update_M(<span class="number">1</span>, <span class="number">1</span>, n, l, r, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;pii&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = st[x].lower_bound(pii(l, l)); it != st[x].end(); it++) &#123;</span><br><span class="line"><span class="built_in">set</span>&lt;pii&gt;::iterator last = it;</span><br><span class="line">last--;</span><br><span class="line"><span class="keyword">int</span> L = (*last).se + <span class="number">1</span>, R = (*it).fi - <span class="number">1</span>;</span><br><span class="line">L = max(L, l);</span><br><span class="line">R = min(R, r);</span><br><span class="line"><span class="keyword">if</span> (L &lt;= R) &#123;</span><br><span class="line">seg.update_M(<span class="number">1</span>, <span class="number">1</span>, n, L, R, inv2);</span><br><span class="line">seg.update_A(<span class="number">1</span>, <span class="number">1</span>, n, L, R, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*it).fi &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">it = st[x].upper_bound(pii(l, l)); it--;</span><br><span class="line">pii p = *it;</span><br><span class="line"><span class="keyword">int</span> L = l, R = r;</span><br><span class="line"><span class="keyword">if</span> (p.se &gt;= L) L = p.fi;</span><br><span class="line">it = st[x].upper_bound(pii(r, r)); it--;</span><br><span class="line">p = *it;</span><br><span class="line"><span class="keyword">if</span> (p.se &gt;= R) R = p.se;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (it = st[x].lower_bound(pii(L, L)); it != st[x].end(); it++) &#123;</span><br><span class="line">p = *it;</span><br><span class="line"><span class="keyword">if</span> (p.fi &gt;= L &amp;&amp; p.se &lt;= R) vec.push_back(p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) st[x].erase(p);</span><br><span class="line">st[x].insert(pii(L, R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">st[i].insert(pii(<span class="number">0</span>, <span class="number">0</span>)), st[i].insert(pii(n + <span class="number">1</span>, n + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, opt, l, r, x; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;opt, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">update(l, r, x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, seg.query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-Antipalindrome&quot;&gt;&lt;a href=&quot;#A-Antipalindrome&quot; class=&quot;headerlink&quot; title=&quot;A. Antipalindrome&quot;&gt;&lt;/a&gt;A. Antipalindrome&lt;/h2&gt;&lt;p&gt;直接暴力判断就行了。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Codeforces" scheme="http://xzt220.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder Grand Contest 020</title>
    <link href="http://xzt220.github.io/2019/09/29/AtCoder-Grand-Contest-020/"/>
    <id>http://xzt220.github.io/2019/09/29/AtCoder-Grand-Contest-020/</id>
    <published>2019-09-29T13:35:22.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<p>tourist’s contest…ssfd<br><a id="more"></a></p><h2 id="A-Move-and-Win"><a href="#A-Move-and-Win" class="headerlink" title="A - Move and Win"></a>A - Move and Win</h2><p>想不到好的博弈方法，我就直接暴力了…<br>可以确定的是，如果一个人觉得他走这个方向是最优的，那么他肯定会一直走下去。<br>那么就枚举四种情况，第一个人往左（往右），第二个人往左（往右）。<br>当第一个人往左（或往右）时，另一个人怎么走都输时他就能赢，否则他就输了。<br>看了别人的代码，好像判一下 $b - a$ 的奇偶性就行了……….<br>好像是的，因为每个人走完一步之后，之间的差的奇偶性还是不改变。<br>我傻逼了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">bool</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>, ans3 = <span class="number">0</span>, ans4 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = b, l = <span class="number">-1</span>, r = <span class="number">-1</span>; i != j; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + l == <span class="number">0</span>) l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i + l == j) &#123;</span><br><span class="line">ans1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += l;</span><br><span class="line"><span class="keyword">if</span> (j + r == i) &#123;</span><br><span class="line">ans1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">j += r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = b, l = <span class="number">-1</span>, r = <span class="number">1</span>; i != j; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + l == <span class="number">0</span>) l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i + l == j) &#123;</span><br><span class="line">ans2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += l;</span><br><span class="line"><span class="keyword">if</span> (j + r &gt; n) r = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (j + r == i) &#123;</span><br><span class="line">ans2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">j += r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = b, l = <span class="number">1</span>, r = <span class="number">-1</span>; i != j; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + l == <span class="number">0</span>) l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i + l == j) &#123;</span><br><span class="line">ans3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += l;</span><br><span class="line"><span class="keyword">if</span> (j + r &gt; n) r = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (j + r == i) &#123;</span><br><span class="line">ans3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">j += r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = b, l = <span class="number">1</span>, r = <span class="number">1</span>; i != j; ) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + l == <span class="number">0</span>) l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i + l == j) &#123;</span><br><span class="line">ans4 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += l;</span><br><span class="line"><span class="keyword">if</span> (j + r &gt; n) r = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (j + r == i) &#123;</span><br><span class="line">ans4 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">j += r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((ans1 &amp;&amp; ans2) || (ans3 &amp;&amp; ans4))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Borys"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Ice-Rink-Game"><a href="#B-Ice-Rink-Game" class="headerlink" title="B - Ice Rink Game"></a>B - Ice Rink Game</h2><p>相当于一个数 $x$，每次进行一次 $\lfloor<script type="math/tex">\dfrac{x}{a_i}</script>\rfloor$ $\times a_i$，最后 $x$ 变成 $2$。<br>倒着进行这个过程，最小化答案的话一定是 $a_i$ 的整数倍，最大化答案的话一定是 $a_i$ 的整数倍加上 $a_i - 1$。<br>那么就倒着递推就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">ll ans1 = <span class="number">2</span>, ans2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">ans1 = (ans1 - <span class="number">1</span>) / a[i] + <span class="number">1</span>, ans2 = ans2 / a[i];</span><br><span class="line"><span class="keyword">if</span> (ans1 &gt; ans2) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans1 *= a[i];</span><br><span class="line">ans2 = ans2 * a[i] + a[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans1, ans2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Median-Sum"><a href="#C-Median-Sum" class="headerlink" title="C - Median Sum"></a>C - Median Sum</h2><p>如果 $S_0$ 也被计入答案的话，那么中位数就肯定是所有答案里面的中位数。<br>因为对于每一种取法得到的答案 $ans$，肯定存在一个 $sum - ans$。<br>所有所有数的中位数即是答案的中位数。<br>除去 $S_0$，答案就在 $\lceil<script type="math/tex">\dfrac{sum}{2}</script>\rceil$ 往上第一个出现的数。<br>那么背包一下一个数是否出现。用bitset优化。<br>复杂度 $O(\dfrac{n ^ 3}{64})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span> * <span class="number">2000</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; mask;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">mask.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">mask = (mask &lt;&lt; x) | mask;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line">        sum++;</span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (!mask.test(sum)) sum++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tourist’s contest…ssfd&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Atcoder" scheme="http://xzt220.github.io/tags/Atcoder/"/>
    
  </entry>
  
  <entry>
    <title>51nod 1803 森林直径</title>
    <link href="http://xzt220.github.io/2019/09/29/51nod-1803-%E6%A3%AE%E6%9E%97%E7%9B%B4%E5%BE%84/"/>
    <id>http://xzt220.github.io/2019/09/29/51nod-1803-%E6%A3%AE%E6%9E%97%E7%9B%B4%E5%BE%84/</id>
    <published>2019-09-29T01:26:17.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1803-森林直径"><a href="#1803-森林直径" class="headerlink" title="1803 森林直径"></a><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1803" target="_blank" rel="noopener">1803 森林直径</a></h1><p>2.0 秒 / 131,072.0 KB / 80 分 / <a href="http://www.51nod.com/Challenge/ProblemList.html#level=6&amp;isAsc=false" target="_blank" rel="noopener">[5级题]</a></p><p>LYK最近在练习数据结构。</p><p>这次它遇到了一棵有n个节点且没有边权没有点权的树。</p><p>一棵树的直径被定义为最远的两个点的距离，LYK想计算出这棵树的直径，但这显然太简单了。</p><p>于是LYK只挑选出其中编号为L到R的边，将其余边在树中删去，那么这棵树就变成了一棵森林。</p><p>我们定义一棵森林的直径为可到达的最远的两个点的距离。（若没有可到达的点对，则森林的直径为0）。</p><p>LYK想知道对于Q组询问，每组询问给出L和R，这棵森林的直径是多少，为了方便起见，你只需输出所有答案的和就可以了。</p><p>由于LYK不知道怎么生成一棵树，于是它打算采取以下方式输出这棵树的所有边。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span>=<span class="number">2</span>; <span class="built_in">i</span>&lt;=n; <span class="built_in">i</span>++) printf(<span class="string">"%d %d\n"</span>,<span class="built_in">rand</span>()<span class="comment">%(i-1)+1,i);</span></span><br></pre></td></tr></table></figure><p>在样例中，4组询问的答案分别为1,2,3,3，因此应当输出9。<br><a id="more"></a></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数n(1&lt;=n&lt;=500000)，表示树的节点个数。<br>接下来n-1行ai与bi，表示编号为i的边所连接的两个节点，按照题目中的输出方式，对于第i条边，有1&lt;=ai&lt;=i,bi=i+1。<br>接下来一行一个数Q(1&lt;=Q&lt;=500000)，表示询问组数。<br>接下来Q行，每行两个数L,R(1&lt;=L&lt;=R&lt;=n)。<br>输出<br>一行表示所有询问答案之和。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>5<br>1 2<br>1 3<br>2 4<br>2 5<br>4<br>1 1<br>1 2<br>1 3<br>1 4</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p>9</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑计算直径的 dp 方法。<br>$d[u]$ 表示以 $u$ 为根的子树能 $u$ 能走到的最远距离<br>$dp[u]$ 表示以 $u$ 为根的子树的直径<br>那么每次dfs一个子节点后<br>$dp[u] = max(d[u] + d[v] + 1, dp[u])$<br>$d[u] = max(d[v] + 1, d[u])$<br>注意顺序一反就错了。<br>这里并没有考虑到 $u$ 是某个节点的儿子是，路径可以往父节点走的情况，但是这是对的。<br>因为如果这种情况存在，那么我们在递归回父节点是就可以更新到。所以直径取最后 dp 数组的最大值是对的。<br>回到这个题，因为数据的生成方式，树高不超过 $log n$，并且第 $i$ 条边一定有 第 $i + 1$个节点。<br>如果从 $[x, n - 1]$ 这棵树已经建好了，那么加入第 $x - 1$ 条边就是把 $p[x - 1]$ 和 $x$ 这两个节点形成的连通块进行合并。<br>深度不超过 $log n$，那么可以暴力一点。<br>将询问离线。按 $r$ 从大到小排序，考虑倒序建这棵树。<br>$f[u][i]$ 表示以 $u$ 为根的子树内 $u$ 能到达的最远距离为 $i$ 时 $r$ 的最小值。即在 $[l, f[u][i]]$ $u$ 能往下走 $i$ 步。<br>$g[i]$ 表示树的直径至少为 $i$ 时 最小的 $r$。即在 $[l, g[i]]$ 树的直径至少为 $i$。<br>倒序加入一条边，相当于两棵树合并，那么就先更新 $g$ 数组，具体更新方式如 $dp$ 的更新方式，分别枚举高度进行合并。<br>$g[i + j + 1] = min(g[i + j + 1], max(f[u][i], f[v][i], v - 1))$ $v-1$ 即为当前加入的边。<br>在更新 $u$，即 $u$ 为 $v$ 的父亲。<br>$f[u][i] = min(f[u][i], max(f[v][i - 1], v - 1))$<br>求答案就枚举高度看 $g$ 数组是否小于当前 $r$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dep = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">In</span> &#123;</span> </span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> In &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l == rhs.l) <span class="keyword">return</span> r &gt; rhs.r;</span><br><span class="line"><span class="keyword">return</span> l &gt; rhs.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125; que[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][dep + <span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> g[dep * <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> p[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dep; i++) <span class="keyword">if</span> (f[u][i] &lt; n)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dep; j++) </span><br><span class="line">g[i + j + <span class="number">1</span>] = min(g[i + j + <span class="number">1</span>], max(f[u][i], max(f[v][j], v - <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dep; i++)</span><br><span class="line">f[u][i] = min(f[u][i], max(f[v][i - <span class="number">1</span>], v - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt; n; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, p + i, &amp;x), f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">f[n][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;que[i].l, &amp;que[i].r);</span><br><span class="line">sort(que + <span class="number">1</span>, que + <span class="number">1</span> + q);</span><br><span class="line"><span class="keyword">int</span> now = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (now &amp;&amp; now &gt;= que[i].l) &#123;</span><br><span class="line">add(p[now], now + <span class="number">1</span>);</span><br><span class="line">now--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = dep * <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[k] &lt;= que[i].r) &#123;</span><br><span class="line">ans += k;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1803-森林直径&quot;&gt;&lt;a href=&quot;#1803-森林直径&quot; class=&quot;headerlink&quot; title=&quot;1803 森林直径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.51nod.com/Challenge/Problem.html#problemId=1803&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1803 森林直径&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;2.0 秒 / 131,072.0 KB / 80 分 / &lt;a href=&quot;http://www.51nod.com/Challenge/ProblemList.html#level=6&amp;amp;isAsc=false&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[5级题]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LYK最近在练习数据结构。&lt;/p&gt;
&lt;p&gt;这次它遇到了一棵有n个节点且没有边权没有点权的树。&lt;/p&gt;
&lt;p&gt;一棵树的直径被定义为最远的两个点的距离，LYK想计算出这棵树的直径，但这显然太简单了。&lt;/p&gt;
&lt;p&gt;于是LYK只挑选出其中编号为L到R的边，将其余边在树中删去，那么这棵树就变成了一棵森林。&lt;/p&gt;
&lt;p&gt;我们定义一棵森林的直径为可到达的最远的两个点的距离。（若没有可到达的点对，则森林的直径为0）。&lt;/p&gt;
&lt;p&gt;LYK想知道对于Q组询问，每组询问给出L和R，这棵森林的直径是多少，为了方便起见，你只需输出所有答案的和就可以了。&lt;/p&gt;
&lt;p&gt;由于LYK不知道怎么生成一棵树，于是它打算采取以下方式输出这棵树的所有边。&lt;/p&gt;
&lt;figure class=&quot;highlight matlab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (int &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;&amp;lt;=n; &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;++) printf(&lt;span class=&quot;string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;rand&lt;/span&gt;()&lt;span class=&quot;comment&quot;&gt;%(i-1)+1,i);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在样例中，4组询问的答案分别为1,2,3,3，因此应当输出9。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="51nod" scheme="http://xzt220.github.io/tags/51nod/"/>
    
  </entry>
  
  <entry>
    <title>Codechef July Challenge 2019 Hit the Coconuts</title>
    <link href="http://xzt220.github.io/2019/09/29/Codechef-July-Challenge-2019-Hit-the-Coconuts/"/>
    <id>http://xzt220.github.io/2019/09/29/Codechef-July-Challenge-2019-Hit-the-Coconuts/</id>
    <published>2019-09-29T01:10:34.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>Nikki has $N$ coconuts, she wants to prepare a special coconut soup for her best friend Mansi. In order to make this soup, she has to break $Z$ coconuts. For each coconut, there is a fixed number of times Nikki needs to hit it if she wants it to break. Nikki can only hit one coconut at the same time.<br><a id="more"></a><br>Their friend Sakshi is a troublemaker. This time, Sakshi shuffled the coconuts in some (unknown) way. You are given a sequence $A_1,A_2,…,A_N$ with the following meaning: it is possible to label the coconuts $1$ through $N$ in such a way that for each valid $i$, the $i$-th coconut needs to be hit exactly $A_i$ times to break.</p><p>Nikki wants to prepare the soup as soon as possible, so she wants to minimise the number of times she has to hit coconuts in the worst case in order to break $Z$ coconuts. Formally, she wants to find a strategy of hitting coconuts, possibly depending on which coconuts broke after which hits, such that no matter which coconuts broke and when, it is guaranteed that after $H$ hits, there will be $Z$ broken coconuts, and there is no strategy with smaller $H$. Help Nikki find $H$ — the minimum required number of hits.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.<br>The first line of each test case contains two space-separated integers $N$ and $Z$.<br>The second line contains N space-separated integers $A_1,A_2,…,A_N$.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, print a single line containing one integer — the minimum required number of hits.</p><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>$1 \leq T \leq 1,000$<br>$1 \leq Z \leq N \leq 10^3$<br>$1 \leq A_i \leq 10^6$ for each valid $i$<br>the sum of $N \times Z$ over all test cases does not exceed $3 \times 10^6$</p><h3 id="Subtasks"><a href="#Subtasks" class="headerlink" title="Subtasks"></a>Subtasks</h3><p><strong>Subtask #$1$ ($10$ points)</strong>:</p><p>$1 \leq T \leq 100$<br>$1 \leq N \leq 500$<br>$Z = 1$<br>$1 \leq A_i \leq 1,000$ for each valid $i$<br>the sum of $N \times Z$ over all test cases does not exceed $3,000$</p><p><strong>Subtask #2 (90 points)</strong>: original constraints</p><h2 id="Example-Input"><a href="#Example-Input" class="headerlink" title="Example Input"></a>Example Input</h2><p>2<br>2 1<br>50 55<br>2 1<br>40 100</p><h2 id="Example-Output"><a href="#Example-Output" class="headerlink" title="Example Output"></a>Example Output</h2><p>55<br>80</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>假设现在有一堆数，我想要保证能取出一个，至少需要敲 （数的个数）*（这些数里的最小值）<br>那么把这些数从大到小排序，$dp[i][j]$ 表示前 $i$ 个里面保证能取出 $j$ 个需要敲的次数。<br>$dp[i][k] = min(dp[j][k - 1] + (i - j) \times a[i])$<br>斜率优化解决。这里的 $a[i]$ 是单调递减的。即斜率是单调递减的。<br>那么下凸壳维护的最优决策点是越来越靠左的，所以pop的是右端，即是一个单调栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">int</span> n, z;</span><br><span class="line">ll a[N], dp[N][N];</span><br><span class="line"><span class="keyword">int</span> que[N], l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cur)</span> </span>&#123; <span class="keyword">return</span> dp[i][cur]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">K</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> cur)</span> </span>&#123; <span class="keyword">return</span> (Y(i, cur) - Y(j, cur)) / (X(i) - X(j)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;z);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, greater&lt;ll&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">dp[i][<span class="number">1</span>] = i * a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= z; k++) &#123;</span><br><span class="line">que[l = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line">que[++r] = k - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; dcmp(K(que[r], que[r - <span class="number">1</span>], k - <span class="number">1</span>) - a[i]) &gt;= <span class="number">0</span>) r--;</span><br><span class="line"><span class="keyword">int</span> j = que[r];</span><br><span class="line">dp[i][k] = dp[j][k - <span class="number">1</span>] + (i - j) * a[i];</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; dcmp(K(que[r], que[r - <span class="number">1</span>], k - <span class="number">1</span>) - K(que[r], i, k - <span class="number">1</span>)) &gt;= <span class="number">0</span>) r--;</span><br><span class="line">que[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = z; i &lt;= n; i++)</span><br><span class="line">ans = min(ans, dp[i][z]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h2&gt;&lt;p&gt;Nikki has $N$ coconuts, she wants to prepare a special coconut soup for her best friend Mansi. In order to make this soup, she has to break $Z$ coconuts. For each coconut, there is a fixed number of times Nikki needs to hit it if she wants it to break. Nikki can only hit one coconut at the same time.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="斜率优化" scheme="http://xzt220.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Codechef July Challenge 2019 Snake and Apple Tree</title>
    <link href="http://xzt220.github.io/2019/09/29/Codechef-July-Challenge-2019-Snake-and-Apple-Tree/"/>
    <id>http://xzt220.github.io/2019/09/29/Codechef-July-Challenge-2019-Snake-and-Apple-Tree/</id>
    <published>2019-09-29T01:08:06.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>Chef is playing a game called “Snake and Apple Tree”. This game is played on a grid with $N$ rows (numbered $1$ through $N$) and $M$ columns (numbered $1$ through $M$). Some cells of this grid are blocked. Initially, there are also $S$ snakes present in $S$ non-blocked cells. The snakes do not grow, so each snake always takes up exactly one cell.<br><a id="more"></a><br>The game starts at second $0$ and will run for $T$ seconds. At the end of each second, each snake may (independently from the other snakes) move to an edge-adjacent non-blocked cell or stay in its current cell. During each second, there may be at most one snake in each cell, but when a snake is moving out of a cell, another snake is allowed to move into that cell at the same time.</p><p>During these $T$ seconds, $Z$ apple trees (numbered $1$ through $Z$) will grow in some cells, bear fruit and wither. For each valid $i$, the $i$-th tree will grow in the cell in row $X_i$ and column $Y_i$ and start bearing fruit at a time $P_i$. At a later time $Q_i$, the tree will wither and bear no fruit. At each second between the $P_i$-th and $Q_i$-th second (including $P_i$, but not including $Q_i$), if there is a snake in the same cell as this tree and it does not move to another cell at the end of this second, it may eat an apple from this tree. Eating one apple from the tree increases the total happiness of the snakes by $H_i$; if a snake eats multiple apples from this tree, the happiness increases by $H_i$ multiple times.</p><p>Each snake takes $1$ second to eat an apple. It cannot do anything else while eating and if there are multiple trees bearing fruit in the same cell, a snake in that cell may only eat an apple from one tree during each second (possibly from different trees during different seconds).</p><p>Initially, the total happiness of the snakes is $0$. Help Chef maximise their happiness after $T$ seconds.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of the input contains four space-separated integers $N$, $M$, $Z$ and $T$.<br>$N$ lines follow. For each $i$ ($1 \leq i \leq N$), the $i$-th of these lines contains a single string with length $M$ describing the $i$-th row of the grid: for each valid $j$, the $j$-th character of this string is ‘#’ if the cell in the $j$-th column of this row is blocked, ‘.’ if it is empty or ‘S’ if it contains a snake.<br>$Z$ lines follow. For each $i$ ($1 \leq i \leq Z$), the $i$-th of these lines contains five space-separated integers $X_i$, $Y_i$, $P_i$, $Q_i$ and $H_i$.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print a single line containing one integer — the maximum total happiness of the snakes.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>费用流。<br>把每个方格拆成 $T$ 个点，$t$ 时刻一个方格向周围四个方格的 $t + 1$ 的点连一条容量为 $1$ 费用为 $0$ 的边，向自身的 $t + 1$ 连一条容量为 $1$ 费用为该方格最大幸福值的边。<br>源点向方格为 ‘S’ 的0时刻连一条容量为 $1$ 费用为 $0$ 的边。所有点的 $T - 1$ 时刻向汇点连一条容量为 $1$ 费用为该方格最大幸福值的边。<br>还有每个格子同时刻不能有多条蛇呆在上面，再把每个点每个时刻拆成两个点，容量为 $1$ 费用为 $0$。跑最大费用最大流即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">1e5</span> + <span class="number">7</span>, M = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">checkmax</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">checkmin</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v, ne, f, c;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="keyword">int</span> head[NN], cnt, tol;</span><br><span class="line"><span class="keyword">int</span> id[N][N][<span class="number">85</span>], mp[N][N][<span class="number">85</span>];</span><br><span class="line"><span class="keyword">int</span> dis[NN], path[NN], n, m, z, t;</span><br><span class="line"><span class="keyword">bool</span> inq[NN];</span><br><span class="line"><span class="keyword">char</span> str[N][N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[cnt].v = v; e[cnt].f = f; e[cnt].c = c; e[cnt].ne = head[u]; head[u] = cnt++;</span><br><span class="line">    e[cnt].v = u; e[cnt].f = <span class="number">0</span>; e[cnt].c = -c; e[cnt].ne = head[v]; head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++)</span><br><span class="line">dis[i] = INF, inq[i] = <span class="number">0</span>, path[i] = <span class="number">-1</span>;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">inq[s] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">inq[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].ne) &#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].v, c = e[i].c;</span><br><span class="line"><span class="keyword">if</span> (e[i].f &amp;&amp; dis[v] &gt; dis[u] + c) &#123;</span><br><span class="line">dis[v] = dis[u] + c;</span><br><span class="line">path[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">inq[v] = <span class="number">1</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mcf</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (spfa(s, t)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = path[t]; ~i; i = path[e[i ^ <span class="number">1</span>].v]) e[i].f--, e[i ^ <span class="number">1</span>].f++;</span><br><span class="line">ans += dis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;z, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= z; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, p, q, h;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x, &amp;y, &amp;p, &amp;q, &amp;h);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; q; j++)</span><br><span class="line">checkmax(mp[x][y][j], h);</span><br><span class="line">&#125;</span><br><span class="line">tol = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (str[i][j] != <span class="string">'#'</span>) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t; k++) &#123;</span><br><span class="line">add(tol, tol + <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; tol &lt;&lt; ' ' &lt;&lt; tol + 1 &lt;&lt; endl;</span></span><br><span class="line">id[i][j][k] = tol;</span><br><span class="line">tol += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S = tol + <span class="number">1</span>, T = tol + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (id[i][j][<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) <span class="keyword">if</span> (id[i + dx[d]][j + dy[d]][<span class="number">0</span>]) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t - <span class="number">1</span>; k++)</span><br><span class="line">add(id[i][j][k] + <span class="number">1</span>, id[i + dx[d]][j + dy[d]][k + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t - <span class="number">1</span>; k++) </span><br><span class="line">add(id[i][j][k] + <span class="number">1</span>, id[i][j][k + <span class="number">1</span>], <span class="number">1</span>, -mp[i][j][k]);</span><br><span class="line">add(id[i][j][t - <span class="number">1</span>] + <span class="number">1</span>, T, <span class="number">1</span>, -mp[i][j][t - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (str[i][j] == <span class="string">'S'</span>) add(S, id[i][j][<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -mcf(S, T));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h2&gt;&lt;p&gt;Chef is playing a game called “Snake and Apple Tree”. This game is played on a grid with $N$ rows (numbered $1$ through $N$) and $M$ columns (numbered $1$ through $M$). Some cells of this grid are blocked. Initially, there are also $S$ snakes present in $S$ non-blocked cells. The snakes do not grow, so each snake always takes up exactly one cell.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="网络流" scheme="http://xzt220.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Gym100676 H. Capital City</title>
    <link href="http://xzt220.github.io/2019/09/28/Gym100676-H-Capital-City/"/>
    <id>http://xzt220.github.io/2019/09/28/Gym100676-H-Capital-City/</id>
    <published>2019-09-27T16:00:54.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<p>感觉题目都已经快把正解给说出来了…<br><a id="more"></a><br>strongly connected的两个点的消耗为0，其实就是同一个边双连通分量里面的点消耗为0。<br>然后缩一下点，再树形DP一下就完了。<br>第一次写边双，但感觉挺简单的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">bool</span> bridge[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v, ne;</span><br><span class="line">ll c;</span><br><span class="line">&#125; e[N * <span class="number">2</span>], tree[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], hd[N], cnt1, cnt2;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], id;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll c)</span> </span>&#123;</span><br><span class="line">e[++cnt1].v = v; e[cnt1].ne = head[u]; e[cnt1].c = c; head[u] = cnt1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll c)</span> </span>&#123;</span><br><span class="line">tree[++cnt2].v = v; tree[cnt2].ne = hd[u]; tree[cnt2].c = c; hd[u] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++id;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].ne) &#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">tarjan(v, i);</span><br><span class="line">low[u] = min(low[u], low[v]);</span><br><span class="line"><span class="keyword">if</span> (low[v] &gt; low[u])</span><br><span class="line">bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != (edge ^ <span class="number">1</span>))</span><br><span class="line">low[u] = min(low[u], dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dcc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">c[u] = dcc;</span><br><span class="line">color[dcc] = min(color[dcc], u);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].ne) &#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span> (c[v] || bridge[i]) <span class="keyword">continue</span>;</span><br><span class="line">dfs0(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dp[u][<span class="number">0</span>] = dp[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">son[u][<span class="number">0</span>] = son[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u]; i; i = tree[i].ne) &#123;</span><br><span class="line"><span class="keyword">int</span> v = tree[i].v;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v, u);</span><br><span class="line"><span class="keyword">if</span> (dp[v][<span class="number">0</span>] + tree[i].c &gt; dp[u][<span class="number">0</span>]) &#123;</span><br><span class="line">dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>];</span><br><span class="line">son[u][<span class="number">1</span>] = son[u][<span class="number">0</span>];</span><br><span class="line">dp[u][<span class="number">0</span>] = dp[v][<span class="number">0</span>] + tree[i].c;</span><br><span class="line">son[u][<span class="number">0</span>] = v;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[v][<span class="number">0</span>] + tree[i].c &gt; dp[u][<span class="number">1</span>]) &#123;</span><br><span class="line">son[u][<span class="number">1</span>] = v;</span><br><span class="line">dp[u][<span class="number">1</span>] = dp[v][<span class="number">0</span>] + tree[i].c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, ll c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fa) &#123;</span><br><span class="line"><span class="keyword">if</span> (son[fa][<span class="number">0</span>] != u) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[fa][<span class="number">0</span>] + c &gt; dp[u][<span class="number">0</span>]) &#123;</span><br><span class="line">dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>];</span><br><span class="line">son[u][<span class="number">1</span>] = son[u][<span class="number">0</span>];</span><br><span class="line">dp[u][<span class="number">0</span>] = dp[fa][<span class="number">0</span>] + c;</span><br><span class="line">son[u][<span class="number">0</span>] = fa;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[fa][<span class="number">0</span>] + c &gt; dp[u][<span class="number">1</span>]) &#123;</span><br><span class="line">son[u][<span class="number">1</span>] = fa;</span><br><span class="line">dp[u][<span class="number">1</span>] = dp[fa][<span class="number">0</span>] + c;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[fa][<span class="number">1</span>] + c &gt; dp[u][<span class="number">0</span>]) &#123;</span><br><span class="line">dp[u][<span class="number">1</span>] = dp[u][<span class="number">0</span>];</span><br><span class="line">son[u][<span class="number">1</span>] = son[u][<span class="number">0</span>];</span><br><span class="line">dp[u][<span class="number">0</span>] = dp[fa][<span class="number">1</span>] + c;</span><br><span class="line">son[u][<span class="number">0</span>] = fa;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[fa][<span class="number">1</span>] + c &gt; dp[u][<span class="number">1</span>]) &#123;</span><br><span class="line">son[u][<span class="number">1</span>] = fa;</span><br><span class="line">dp[u][<span class="number">1</span>] = dp[fa][<span class="number">1</span>] + c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u]; i; i = tree[i].ne) &#123;</span><br><span class="line"><span class="keyword">int</span> v = tree[i].v;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(v, u, tree[i].c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">head[i] = hd[i] = <span class="number">0</span>;</span><br><span class="line">c[i] = <span class="number">0</span>;</span><br><span class="line">low[i] = dfn[i] = <span class="number">0</span>;</span><br><span class="line">color[i] = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(bridge, <span class="number">0</span>, <span class="keyword">sizeof</span>(bridge));</span><br><span class="line">cnt1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">ll c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">add1(u, v, c);</span><br><span class="line">add1(v, u, c);</span><br><span class="line">&#125;</span><br><span class="line">id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (!dfn[i])</span><br><span class="line">tarjan(i, <span class="number">0</span>);</span><br><span class="line">dcc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (!c[i]) &#123;</span><br><span class="line">++dcc;</span><br><span class="line">dfs0(i);</span><br><span class="line">&#125;</span><br><span class="line">cnt2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt1; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = e[i ^ <span class="number">1</span>].v, v = e[i].v;</span><br><span class="line"><span class="keyword">if</span> (c[u] == c[v]) <span class="keyword">continue</span>;</span><br><span class="line">add2(c[u], c[v], e[i].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ans1 = <span class="number">0</span>; ll ans2 = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dcc; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][<span class="number">0</span>] &lt; ans2) ans2 = dp[i][<span class="number">0</span>], ans1 = color[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[i][<span class="number">0</span>] == ans2 &amp;&amp; ans1 &gt; color[i]) ans1 = color[i];</span><br><span class="line"><span class="comment">//printf("%lld\n", dp[i][0]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %lld\n"</span>, ans1, ans2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉题目都已经快把正解给说出来了…&lt;br&gt;
    
    </summary>
    
    
    
      <category term="树形DP" scheme="http://xzt220.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="双连通分量" scheme="http://xzt220.github.io/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>牛客挑战赛32 E. 树上逆序对</title>
    <link href="http://xzt220.github.io/2019/09/27/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B32-E-%E6%A0%91%E4%B8%8A%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://xzt220.github.io/2019/09/27/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B32-E-%E6%A0%91%E4%B8%8A%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2019-09-26T16:07:39.000Z</published>
    <updated>2020-07-31T03:08:22.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在可能性的系统树上，一共有 $n$ 个事件，正如它们的名字一般，它们形成了一棵树的关系。</p><p>现在我们默认 $1$ 号事件是所有事件的根节点。不同的事件会产生不同的可能性，为了区分，每一个事件有一个关键值 $a_i$，并且保证各不相同。</p><p>您拥有 “Rewrite” 的能力，在这棵可能性的系统树上，您可以对任意一个事件进行改写，让它的关键值变成 -$a_i$。为了创造新的可能性，你需要让这棵树的树上逆序对数为 $k$ .</p><p>来自篝火的指引：树上逆序对的定义：若有一对节点 $(x,y)$，满足 $x$ 是 $y$ 的祖先，且 $x$ 点权值大于 $y$ 点的权值，则 $(x,y)$ 为一个树上逆序对。</p><p>由于需要尽可能多的探索生命的可能，您会进行 $q$ 次询问。</p><a id="more"></a><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>输入的第一行包含一个整数 $n$，表示事件数。</p><p>第二行 $n$ 个正整数，表示每个节点初始的关键值，每个关键值都各不相同。</p><p>接下来 $n-1$ 行，每行两个数 $x$,$y$ 表示 $x$, $y$ 之间有树边相连。</p><p>下面一行 $q$ 表示询问个数。</p><p>接下来 $q$ 行，每行一个数 $k$ 表示询问树上逆序对数能否为 $k$。</p><p>100%的数据，满足 $1 \leq x,y \leq n$, $n$ , $q \leq 100000$, $k \leq 30000$, $a_i \leq 100000000$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>对于每次询问，若可以为 $k$ 输出“Orz”，若不可以输出“QAQ”。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Orz</span></span><br><span class="line"><span class="attribute">Orz</span></span><br></pre></td></tr></table></figure><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>对于一对 $(x, y)$，能成为逆序对的取决于绝对值大的那个数的符号。<br>假如 $a[x] &gt; a[y]$，当 $a[x]$ 为正时，不管 $a[y]$ 取不取负号都比 $a[x]$ 小。<br>当 $a[x]$ 为负时， 不管 $a[y]$ 取不取负号都比 $a[x]$ 大。<br>那么就变成了统计每个节点的子树及祖先有多少个比它的权值小的。取正时，子树内权值比它小的节点对答案有贡献，取负时，祖先中权值比它的节点对答案有贡献。<br>然后就相当于01背包了。<br>用bitset优化一下复杂度就是 $O(\dfrac{nk}{64})$<br>求子树内和到根的路径上比该节点小的数可以树剖做。但看了tangjz的代码发现一个更加巧妙的方法。<br>求子树内显然可以从小到大插入节点+dfs序+树状数组。<br>求该节点到根的路径上比自己权值大的，就相当于求自己有几个祖先，相当于求自己在多少个节点的子树内。<br>那么多开一个树状数组，在插入一个节点时，让其子树这个区间（不包括自身）区间加一。查询时单点查值就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;30001&gt; mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tree[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">tree[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i)) </span><br><span class="line">ans += tree[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; bit[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], in[N], out[N], tol, o[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">in[u] = ++tol;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u])</span><br><span class="line"><span class="keyword">if</span> (v != fa) dfs(v, u);</span><br><span class="line">out[u] = tol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">o[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(o + <span class="number">1</span>, o + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">mask.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = o[i];</span><br><span class="line"><span class="keyword">int</span> k1 = bit[<span class="number">0</span>].query(in[u]), k2 = bit[<span class="number">1</span>].query(out[u]) - bit[<span class="number">1</span>].query(in[u] - <span class="number">1</span>);</span><br><span class="line">mask = mask &lt;&lt; k1 | mask &lt;&lt; k2;</span><br><span class="line">bit[<span class="number">0</span>].add(in[u] + <span class="number">1</span>, <span class="number">1</span>); bit[<span class="number">0</span>].add(out[u] + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">bit[<span class="number">1</span>].add(in[u], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"><span class="built_in">puts</span>(mask.test(k) ? <span class="string">"Orz"</span> : <span class="string">"QAQ"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在可能性的系统树上，一共有 $n$ 个事件，正如它们的名字一般，它们形成了一棵树的关系。&lt;/p&gt;
&lt;p&gt;现在我们默认 $1$ 号事件是所有事件的根节点。不同的事件会产生不同的可能性，为了区分，每一个事件有一个关键值 $a_i$，并且保证各不相同。&lt;/p&gt;
&lt;p&gt;您拥有 “Rewrite” 的能力，在这棵可能性的系统树上，您可以对任意一个事件进行改写，让它的关键值变成 -$a_i$。为了创造新的可能性，你需要让这棵树的树上逆序对数为 $k$ .&lt;/p&gt;
&lt;p&gt;来自篝火的指引：树上逆序对的定义：若有一对节点 $(x,y)$，满足 $x$ 是 $y$ 的祖先，且 $x$ 点权值大于 $y$ 点的权值，则 $(x,y)$ 为一个树上逆序对。&lt;/p&gt;
&lt;p&gt;由于需要尽可能多的探索生命的可能，您会进行 $q$ 次询问。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="树状数组" scheme="http://xzt220.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="dfs序" scheme="http://xzt220.github.io/tags/dfs%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #321 (Div. 2)</title>
    <link href="http://xzt220.github.io/2019/09/26/Codeforces-Round-321-Div-2/"/>
    <id>http://xzt220.github.io/2019/09/26/Codeforces-Round-321-Div-2/</id>
    <published>2019-09-26T13:25:32.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Kefa-and-First-Steps"><a href="#A-Kefa-and-First-Steps" class="headerlink" title="A. Kefa and First Steps"></a>A. Kefa and First Steps</h2><a id="more"></a><p>求最长递增连续子序列。</p><h2 id="B-Kefa-and-Company"><a href="#B-Kefa-and-Company" class="headerlink" title="B. Kefa and Company"></a>B. Kefa and Company</h2><p>排序二分就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">ll m, s;</span><br><span class="line">P(ll m = <span class="number">0</span>, ll s = <span class="number">0</span>): m(m), s(s) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> P &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> m &lt; rhs.m;</span><br><span class="line">&#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p[i].m, &amp;p[i].s);</span><br><span class="line">sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + p[i].s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> pos = upper_bound(p + i + <span class="number">1</span>, p + n + <span class="number">1</span>, P(d + p[i].m - <span class="number">1</span>, <span class="number">0</span>)) - p;</span><br><span class="line">pos--;</span><br><span class="line"><span class="keyword">if</span> (pos &lt; i) <span class="keyword">continue</span>;</span><br><span class="line">ans = max(ans, sum[pos] - sum[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Kefa-and-Park"><a href="#C-Kefa-and-Park" class="headerlink" title="C. Kefa and Park"></a>C. Kefa and Park</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> havecat[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> con)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (G[u].size() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (con &lt;= m) ans++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!havecat[v]) dfs(v, u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (con + <span class="number">1</span> &lt;= m) dfs(v, u, con + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;havecat[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">G[<span class="number">1</span>].push_back(<span class="number">0</span>);</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, havecat[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Kefa-and-Dishes"><a href="#D-Kefa-and-Dishes" class="headerlink" title="D. Kefa and Dishes"></a>D. Kefa and Dishes</h2><p>显然状压，因为吃了一些菜品之后，只跟最后一个吃的是哪一个有关，即一个集合只跟最后一个加入的元素有关。<br>$dp[s][i]$ 表示吃了集合 $s$ 的菜品，最后一个吃的是第 $i$ 个菜品。<br>转移 $dp[s | (1 &lt;&lt; j)] = dp[s] + a[j] + c[i][j]$<br>吃了 $m$ 个菜品就在转移过程中计算就行了。<br>复杂度 $O(n^2 2^n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = (<span class="number">1</span> &lt;&lt; N) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ll mp[N][N], dp[sz][N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getone</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (s) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">s &amp;= (s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">checkmax</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), dp[<span class="number">1</span> &lt;&lt; i][i] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v; ll c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">u--, v--;</span><br><span class="line">mp[u][v] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; S; s++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> ((s &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; dp[s][i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (getone(s) == m) checkmax(ans, dp[s][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!(s &gt;&gt; j &amp; <span class="number">1</span>)) </span><br><span class="line">checkmax(dp[s | (<span class="number">1</span> &lt;&lt; j)][j], dp[s][i] + a[j] + mp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Kefa-and-Watch"><a href="#E-Kefa-and-Watch" class="headerlink" title="E. Kefa and Watch"></a>E. Kefa and Watch</h2><p>题意：<br>给一个数字串。操作一为区间修改。操作二询问一个区间是否周期为 $d$</p><p>思路：<br>判断周期可以用哈希。<br>相当于有 $|s| - d$ 个等式。<br>$s[l] = s[l + d]$<br>$s[l + 1] = s[l + d + 1]$<br>$\dots$<br>$s[r - d] = s[r]$<br>把左边和右边分别拼起来就是判 $[l, r - d]$ 和 $[l + d, r]$ 相同<br>那么线段树维护哈希值即可。<br>刚开始用自然溢出，两个seed咋改都没用。<br>然后用了两个模数才行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rp p &lt;&lt; 1 | 1</span></span><br><span class="line">ull tree[N * <span class="number">4</span>], bit[N], sum[N], seed, MOD;</span><br><span class="line"><span class="keyword">int</span> lazy[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bit[<span class="number">0</span>] = sum[<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">bit[i] = (bit[i - <span class="number">1</span>] * seed) % MOD;</span><br><span class="line">sum[i] = (sum[i - <span class="number">1</span>] + bit[i]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> llen, <span class="keyword">int</span> rlen)</span> </span>&#123;</span><br><span class="line">tree[p] = (tree[lp] * bit[rlen] % MOD + tree[rp]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tag</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> dig, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">lazy[p] = dig;</span><br><span class="line">tree[p] = sum[len - <span class="number">1</span>] * dig % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> llen, <span class="keyword">int</span> rlen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lazy[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">tag(lp, lazy[p], llen);</span><br><span class="line">tag(rp, lazy[p], rlen);</span><br><span class="line">lazy[p] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">lazy[p] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tree[p] = s[l] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lp, l, mid);</span><br><span class="line">build(rp, mid + <span class="number">1</span>, r);</span><br><span class="line">pushup(p, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) &#123;</span><br><span class="line">lazy[p] = dig;</span><br><span class="line">tree[p] = dig * sum[r - l] % MOD;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushdown(p, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update(lp, l, mid, x, y, dig);</span><br><span class="line"><span class="keyword">if</span> (y &gt; mid) update(rp, mid + <span class="number">1</span>, r, x, y, dig);</span><br><span class="line">pushup(p, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushdown(p, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line"><span class="keyword">if</span> (y &lt;= mid) <span class="keyword">return</span> query(lp, l, mid, x, y);</span><br><span class="line"><span class="keyword">if</span> (x &gt; mid) <span class="keyword">return</span> query(rp, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line"><span class="keyword">return</span> (query(lp, l, mid, x, y) * bit[min(y, r) - (mid + <span class="number">1</span>) + <span class="number">1</span>] % MOD + query(rp, mid + <span class="number">1</span>, r, x, y)) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">m += k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">seg[<span class="number">0</span>].seed = <span class="number">233</span>; seg[<span class="number">0</span>].MOD = <span class="number">201326611</span>;</span><br><span class="line">seg[<span class="number">1</span>].seed = <span class="number">2333</span>; seg[<span class="number">1</span>].MOD = <span class="number">402653189</span>;</span><br><span class="line">seg[<span class="number">0</span>].init(); seg[<span class="number">1</span>].init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> opt, l, r, d; m--; ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;opt, &amp;l, &amp;r, &amp;d);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">seg[i].update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, d);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l + <span class="number">1</span> == d || (seg[<span class="number">0</span>].query(<span class="number">1</span>, <span class="number">1</span>, n, l, r - d) == seg[<span class="number">0</span>].query(<span class="number">1</span>, <span class="number">1</span>, n, l + d, r) &amp;&amp; seg[<span class="number">1</span>].query(<span class="number">1</span>, <span class="number">1</span>, n, l, r - d) == seg[<span class="number">1</span>].query(<span class="number">1</span>, <span class="number">1</span>, n, l + d, r))) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-Kefa-and-First-Steps&quot;&gt;&lt;a href=&quot;#A-Kefa-and-First-Steps&quot; class=&quot;headerlink&quot; title=&quot;A. Kefa and First Steps&quot;&gt;&lt;/a&gt;A. Kefa and First Steps&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Codeforces" scheme="http://xzt220.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #320 (Div. 2) [Bayan Thanks-Round]</title>
    <link href="http://xzt220.github.io/2019/09/25/Codeforces-Round-320-Div-2-Bayan-Thanks-Round/"/>
    <id>http://xzt220.github.io/2019/09/25/Codeforces-Round-320-Div-2-Bayan-Thanks-Round/</id>
    <published>2019-09-25T13:41:58.000Z</published>
    <updated>2020-07-31T03:08:22.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Raising-Bacteria"><a href="#A-Raising-Bacteria" class="headerlink" title="A. Raising Bacteria"></a>A. Raising Bacteria</h2><p>数二进制位有多少个1就好了。<a id="more"></a></p><h2 id="B-Finding-Team-Member"><a href="#B-Finding-Team-Member" class="headerlink" title="B. Finding Team Member"></a>B. Finding Team Member</h2><p>题意：<br>有 $2n$ 个人，任意两个人配对有一个价值，如果一人的目前的最优配对那个人的最优配对也是自己，那么两个人可以配对。</p><p>思路：<br>直接模拟，每次至少能让两个人配对成功。所以复杂度 $O(n ^ 2)$，刚开始用优先队列写了一发，发现RE了，以为是优先队列出锅了，最后才发现是数组开小了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">840</span>;</span><br><span class="line">priority_queue&lt;pii&gt; que[N];</span><br><span class="line"><span class="keyword">int</span> who[N];</span><br><span class="line"><span class="keyword">int</span> best[N][N];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">que[i].push(pii(x, j));</span><br><span class="line">que[j].push(pii(x, i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">pos[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!que[i].empty()) &#123;</span><br><span class="line">best[i][++cnt] = que[i].top().se;</span><br><span class="line">que[i].pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (who[i]) &#123;</span><br><span class="line">pos[i] = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pos[i] &lt;= <span class="number">2</span> * n &amp;&amp; who[best[i][pos[i]]]) pos[i]++;</span><br><span class="line"><span class="keyword">if</span> (pos[i] &lt;= <span class="number">2</span> * n) &#123;</span><br><span class="line"><span class="keyword">int</span> ne = best[i][pos[i]];</span><br><span class="line"><span class="keyword">while</span> (pos[ne] &lt;= <span class="number">2</span> * n &amp;&amp; who[best[ne][pos[ne]]]) pos[ne]++;</span><br><span class="line"><span class="keyword">if</span> (pos[ne] &lt;= <span class="number">2</span> * n &amp;&amp; best[ne][pos[ne]] == i) &#123;</span><br><span class="line">pos[ne] = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">pos[i] = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">who[i] = ne;</span><br><span class="line">who[ne] = i;</span><br><span class="line"><span class="comment">//printf("%d %d\n", i, ne);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d\n", pos[2]);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line"><span class="keyword">if</span> (!who[i]) flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%c"</span>, who[i], <span class="string">" \n"</span>[i == <span class="number">2</span> * n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-A-Problem-about-Polyline"><a href="#C-A-Problem-about-Polyline" class="headerlink" title="C. A Problem about Polyline"></a>C. A Problem about Polyline</h2><p>题意：<br>有一条折线，$(0,0)$ – $(x, x)$ – $(2x, 0)$ – $(3x, x)$ – $(4x, 0)$ – $\dots$ - $(2kx, 0)$ – $(2kx + x, x)$ - $\dots$<br>给出一个点 $(a, b)$，问存不存在最小的 $x$ 使得点 $(a, b)$ 在折线上。</p><p>思路：<br>$a &lt; b$ 显然没有。<br>若答案存在，分为两种情况，点 $(a, b)$ 在奇数段和偶数段上。<br>在奇数段满足 $a - (k - 1)x = b$，即 $a - b = (k - 1)x$ $k$ 为奇数。<br>在偶数段满足 $a - kx = -b$， 即 $a + b = kx$,  $k$ 为偶数。<br>把第一种情况的 $k$ 看成 $k - 1$，两个情况就只有左边不一样了。<br>分别求一下答案就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> z = sum / b;</span><br><span class="line"><span class="keyword">while</span> (z &amp;&amp; (z &amp; <span class="number">1</span> || sum / z &lt; b)) z--;</span><br><span class="line"><span class="keyword">if</span> (!z) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span> * sum / z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, b);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">".0000000000000"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans1 = get(a + b, b);</span><br><span class="line"><span class="keyword">double</span> ans2 = get(a - b, b);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(ans1 + <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">fabs</span>(ans2 + <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fabs</span>(ans1 + <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>, ans2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fabs</span>(ans2 + <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>, ans1);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>, min(ans1, ans2));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-“Or”-Game"><a href="#D-“Or”-Game" class="headerlink" title="D. “Or” Game"></a>D. “Or” Game</h2><p>题意：<br>有 $n$ 个数，给你 $k$ 次操作，每次操作是任选一个数能给它乘上一个给的数 $x$。问最后所有数或起来最大为多少。</p><p>思路：<br>搞了半天DP，发现是错的。因为当前最优不一定能使后面最优。<br>发现乘法相当于让这个数二进制位往高处移，那么把这些操作分散给几个数肯定不比直接给一个数来的优。<br>所以直接枚举哪个数来乘上这个数就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll pre[N], last[N];</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll x;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll x, ll y, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">ll ans = x;</span><br><span class="line"><span class="keyword">while</span> (cnt--) ans *= y;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;n, &amp;k, &amp;x);</span><br><span class="line">ll m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k--) m *= x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), pre[i] = pre[i - <span class="number">1</span>] | a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">last[i] = last[i + <span class="number">1</span>] | a[i];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans = max(ans, pre[i - <span class="number">1</span>] | (a[i] * m) | last[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Weakness-and-Poorness"><a href="#E-Weakness-and-Poorness" class="headerlink" title="E. Weakness and Poorness"></a>E. Weakness and Poorness</h2><p>题意：<br>给一个序列，求一个 $x$ 使得这个序列每个数都减去 $x$ 后的子段和中绝对值最大的那个最小。</p><p>思路：<br>听起来很像数学中的函数，$x$ 做自变量，子段和做因变量，求一个极值，当 $x$ 很小时，最大子段和显然会很大，当 $x$ 很大时，数字变成负的很小，子段和取绝对值之后又会很大。<br>所以这个就是一个单峰函数。<br>三分极值点，$O(n)$ 求最大子段和，因为涉及绝对值，就可以所有数乘以-1再做一次，两次得到的值取最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">double</span> k[N];</span><br><span class="line"><span class="keyword">double</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">k[i] = a[i] - x;</span><br><span class="line">f[<span class="number">1</span>] = k[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> ans = f[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i] = max(f[i - <span class="number">1</span>], <span class="number">0.0</span>) + k[i];</span><br><span class="line">ans = max(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">k[i] *= <span class="number">-1</span>;</span><br><span class="line">f[<span class="number">1</span>] = k[<span class="number">1</span>];</span><br><span class="line">ans = max(ans, f[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i] = max(f[i - <span class="number">1</span>], <span class="number">0.0</span>) + k[i];</span><br><span class="line">ans = max(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">-1e5</span>, r = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; <span class="number">200</span>; cnt++) &#123;</span><br><span class="line"><span class="keyword">double</span> ll = l + (r - l) / <span class="number">3.0</span>, rr = r - (r - l) / <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">if</span> (check(ll) &gt; check(rr)) l = ll;</span><br><span class="line"><span class="keyword">else</span> r = rr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>, check(l));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-LCS-Again"><a href="#F-LCS-Again" class="headerlink" title="F. LCS Again"></a>F. LCS Again</h2><p>题意：<br>给一个串，长度为 $n$, 给出字符集大小，问能构造出多少长度为 $n$，并且LCS为 $n - 1$ 的串。</p><p>思路：<br>题解没看懂。讨论区的做法很妙。<br>构造过程就相当于在原串中拿一个位置的字符，再重新任意放回原串。<br>把颜色相同且连续的看成一段，假设长度为 $g$，字符为 $c$。那么从中取一个 $c$ 再变成任意一种字符放回原串，方案数为 $nm$<br>不过你不能把一个 $c$ 又放回这一段中，不合法的方案是 $g$。<br>假设有另外一段字符为 $d$ 长度为 $h$ 的子串，把 $c$ 变成 $d$ 再放入这个段显然只有一种放法。而总放法是 $h + 1$，那么不合法的方案是 $h$。<br>所以总共的不合法方案就是 $n$。所以对每一段的答案为 $nm - n$，如果有 $k$ 段，则答案为 $k(nm - n)$。<br>还有一种重复的情况，如 $ababa$ 变成 $babab$，可以是第一个字符变成 $b$ 放到最后，也可以是最后一个字符变成 $b$ 放到开头。<br>这种就是长度大于等于 $2$ 的，用了两种字符的就会重复。用了三种字符的就不会影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, s);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = n * (m - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">if</span> (s[i] != s[i - <span class="number">1</span>])</span><br><span class="line">ans += n * (m - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> cur++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[i - <span class="number">2</span>]) cur++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans -= <span class="number">1L</span>L * cur * (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> cur = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, cur);</span><br><span class="line">&#125;</span><br><span class="line">ans -= <span class="number">1L</span>L * cur * (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-Raising-Bacteria&quot;&gt;&lt;a href=&quot;#A-Raising-Bacteria&quot; class=&quot;headerlink&quot; title=&quot;A. Raising Bacteria&quot;&gt;&lt;/a&gt;A. Raising Bacteria&lt;/h2&gt;&lt;p&gt;数二进制位有多少个1就好了。
    
    </summary>
    
    
    
      <category term="Codeforces" scheme="http://xzt220.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4518 [Sdoi2016]征途</title>
    <link href="http://xzt220.github.io/2019/09/25/BZOJ4518-Sdoi2016-%E5%BE%81%E9%80%94/"/>
    <id>http://xzt220.github.io/2019/09/25/BZOJ4518-Sdoi2016-%E5%BE%81%E9%80%94/</id>
    <published>2019-09-25T13:12:39.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4518-Sdoi2016-征途"><a href="#4518-Sdoi2016-征途" class="headerlink" title="   4518: [Sdoi2016]征途 "></a><center>  <font color = blue> 4518: [Sdoi2016]征途 </center></h1><center><a href="https://www.lydsy.com/JudgeOnline/submitpage.php?id=4518" target="_blank" rel="noopener">[Submit]</a><a href="https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4518" target="_blank" rel="noopener">[Statics]</a><a href="https://www.lydsy.com/JudgeOnline/bbs.php?id=2286" target="_blank" rel="noopener">[Discuss]</a></center><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a><font color = blue>Description</h2><p>Pine开始了从S地到T地的征途。<br>从S地到T地的路可以划分成n段，相邻两段路的分界点设有休息站。<br>Pine计划用m天到达T地。除第m天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。<br>Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。<br>帮助Pine求出最小方差是多少。<br>设方差是v，可以证明，v×m^2是一个整数。为了避免精度误差，输出结果时输出v×m^2。<br><a id="more"></a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><font color = blue>Input</h2><p>第一行两个数 n、m。<br>第二行 n 个数，表示 n 段路的长度</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><font color = blue>Output</h2><p>一个数，最小方差乘以 m^2 后的值</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a><font color = blue>Sample Input</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a><font color = blue>Sample Output</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a><font color = blue>HINT</h2><p>1≤n≤3000,保证从 S 到 T 的总路程不超过 30000</p><center><a href="https://www.lydsy.com/JudgeOnline/submitpage.php?id=4518" target="_blank" rel="noopener">[Submit]</a><a href="https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4518" target="_blank" rel="noopener">[Statics]</a><a href="https://www.lydsy.com/JudgeOnline/bbs.php?id=2286" target="_blank" rel="noopener">[Discuss]</a></center><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><font color = blue>Solution</h2><p>设最后 $m$ 段每段数字之和为 $a<em>i$，那么最后答案为 $m^2 \sum \dfrac {\left( a</em>{i}-\dfrac {s}{m}\right) ^{2}}{m}$<br>把括号拆开后最后答案为 $m\sum a_i ^{2}-S^{2}$<br>要求最小化$\sum a_i ^{2}$，那么直接上斜率优化<br>$dp[i][k]$ 表示在 $i$ 处做第 $k$ 次休息。<br>那么 $dp[i][k] = min(dp[j][k - 1]) + (sum[i] - sum[j])^2$<br>$dp[i][k] + 2 \times sum[i] \times sum[j] = dp[j][k - 1] + sum[j] ^ 2 + sum[i] ^ 2$<br>斜率为 $2 \times sum[i]$，自变量为 $sum[j]$，截距为 $dp[i][k]$，因变量为 $dp[j][k - 1] + sum[j] ^ 2 + sum[i] ^ 2$。<br>求截距最小值即可。由于斜率单调，由决策单调性可 $O(1)$ 得到最优决策点。<br>时间复杂度 $O(nm)$<br>边界为 $dp[i][0] = sum[i] ^ 2$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) ? EOF : *p1++)</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; T f = <span class="number">1</span>; <span class="keyword">char</span> ch = gc();</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = gc(); &#125;</span><br><span class="line">        x *= f;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">2</span>], s[N];</span><br><span class="line"><span class="keyword">int</span> n, m, que[N], l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> s[i]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cur)</span> </span>&#123; <span class="keyword">return</span> dp[i][cur] + sqr(s[i]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">K</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line"><span class="comment">//if (X(i) == X(j)) return 0;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span> * (Y(i, cur) - Y(j, cur)) / (X(i) - X(j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(s[i]), s[i] += s[i - <span class="number">1</span>], dp[i][<span class="number">0</span>] = sqr(s[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m - <span class="number">1</span>; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur = k &amp; <span class="number">1</span>;</span><br><span class="line">que[l = r = <span class="number">1</span>] = k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; dcmp(K(que[l], que[l + <span class="number">1</span>], cur ^ <span class="number">1</span>) - <span class="number">2</span> * s[i]) &lt; <span class="number">0</span>) l++;</span><br><span class="line"><span class="keyword">int</span> j = que[l];</span><br><span class="line">dp[i][cur] = dp[j][cur ^ <span class="number">1</span>] + sqr(s[i] - s[j]);</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; dcmp(K(que[r], que[r - <span class="number">1</span>], cur ^ <span class="number">1</span>) - K(que[r], i, cur ^ <span class="number">1</span>)) &gt; <span class="number">0</span>) r--;</span><br><span class="line">que[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m * dp[n][(m - <span class="number">1</span>) &amp; <span class="number">1</span>] - sqr(s[n]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;4518-Sdoi2016-征途&quot;&gt;&lt;a href=&quot;#4518-Sdoi2016-征途&quot; class=&quot;headerlink&quot; title=&quot;   4518: [Sdoi2016]征途 &quot;&gt;&lt;/a&gt;&lt;center&gt;  &lt;font color = blue&gt; 4518: [Sdoi2016]征途 &lt;/center&gt;&lt;/h1&gt;&lt;center&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/submitpage.php?id=4518&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Submit]&lt;/a&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4518&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Statics]&lt;/a&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/bbs.php?id=2286&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Discuss]&lt;/a&gt;&lt;/center&gt;


&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;font color = blue&gt;Description&lt;/h2&gt;&lt;p&gt;Pine开始了从S地到T地的征途。&lt;br&gt;从S地到T地的路可以划分成n段，相邻两段路的分界点设有休息站。&lt;br&gt;Pine计划用m天到达T地。除第m天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。&lt;br&gt;Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。&lt;br&gt;帮助Pine求出最小方差是多少。&lt;br&gt;设方差是v，可以证明，v×m^2是一个整数。为了避免精度误差，输出结果时输出v×m^2。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="斜率优化" scheme="http://xzt220.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4241 历史研究</title>
    <link href="http://xzt220.github.io/2019/09/25/BZOJ4241-%E5%8E%86%E5%8F%B2%E7%A0%94%E7%A9%B6/"/>
    <id>http://xzt220.github.io/2019/09/25/BZOJ4241-%E5%8E%86%E5%8F%B2%E7%A0%94%E7%A9%B6/</id>
    <published>2019-09-25T12:57:42.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4241-历史研究"><a href="#4241-历史研究" class="headerlink" title="   4241: 历史研究 "></a><center>  <font color = blue> 4241: 历史研究 </center></h1><center><a href="https://www.lydsy.com/JudgeOnline/submitpage.php?id=4241" target="_blank" rel="noopener">[Submit]</a><a href="https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4241" target="_blank" rel="noopener">[Statics]</a><a href="https://www.lydsy.com/JudgeOnline/bbs.php?id=2286" target="_blank" rel="noopener">[Discuss]</a></center><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a><font color = blue>Description</h2><p>IOI国历史研究的第一人——JOI教授，最近获得了一份被认为是古代IOI国的住民写下的日记。JOI教授为了通过这份日记来研究古代IOI国的生活，开始着手调查日记中记载的事件。<br>日记中记录了连续N天发生的时间，大约每天发生一件。<br>事件有种类之分。第 $i$ 天($1 \leq i \leq N$)发生的事件的种类用一个整数 $X_i$ 表示，$X_i$ 越大，事件的规模就越大。<br>JOI教授决定用如下的方法分析这些日记：<br>    1.选择日记中连续的一些天作为分析的时间段<br>    2.事件种类t的重要度为 t*(这段时间内重要度为t的事件数)<br>    3.计算出所有事件种类的重要度，输出其中的最大值<br>现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值。<br><a id="more"></a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><font color = blue>Input</h2><p>第一行两个空格分隔的整数 $N$ 和 $Q$，表示日记一共记录了 $N$ 天，询问有 $Q$ 次。<br>接下来一行 $N$ 个空格分隔的整数 $X_1 \dots X_N$，$X_i$ 表示第 $i$ 天发生的事件的种类<br>接下来 $Q$ 行，第 $i$ 行($1 \leq i \leq Q$)有两个空格分隔整数 $A_i$ 和 $B_i$，表示第 $i$ 次询问的区间为[$A_i$, $B_i$]。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><font color = blue>Output</h2><p>输出 $Q$ 行，第 $i$ 行($1 \leq i \leq Q)一个整数，表示第i次询问的最大重要度</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a><font color = blue>Sample Input</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">8</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a><font color = blue>Sample Output</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a><font color = blue>HINT</h2><p>$1 \leq N \leq 10^5$</p><p>$1 \leq Q \leq 10^5$</p><p>$1 \leq X_i \leq 10^9$ ($1 \leq i \leq N$)</p><center><a href="https://www.lydsy.com/JudgeOnline/submitpage.php?id=4241" target="_blank" rel="noopener">[Submit]</a><a href="https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4241" target="_blank" rel="noopener">[Statics]</a><a href="https://www.lydsy.com/JudgeOnline/bbs.php?id=2286" target="_blank" rel="noopener">[Discuss]</a></center><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><font color = blue>Solution</h2><p>感觉这种信息不符合区间可加性，或者用来区间相加的时间复杂度太高的话就直接分块。<br>res[i][j] 表示第 $i$ 块到第 $j$ 块之间的答案，查询就先查询整块，再对两端暴力。<br>注意不要用memset清空cnt数组，每次使用了再循环一遍撤销操作就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) ? EOF : *p1++)</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; T f = <span class="number">1</span>; <span class="keyword">char</span> ch = gc();</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = gc(); &#125;</span><br><span class="line">        x *= f;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BLOCK = <span class="built_in">sqrt</span>(N) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[N], v[N], tol;</span><br><span class="line"><span class="keyword">int</span> l[BLOCK], r[BLOCK], block, num, belong[N];</span><br><span class="line">ll res[BLOCK][BLOCK], cnt[N], sum[BLOCK][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">checkmax</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">num = n / block;</span><br><span class="line"><span class="keyword">if</span> (n % block) num++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">l[i] = (i - <span class="number">1</span>) * block + <span class="number">1</span>, r[i] = i * block;</span><br><span class="line">r[num] = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= r[i]; j++)</span><br><span class="line">belong[j] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tol; j++)</span><br><span class="line">cnt[j] = <span class="number">0</span>, sum[i][j] = sum[i - <span class="number">1</span>][j];</span><br><span class="line">ll mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= n; j++) &#123;</span><br><span class="line">cnt[a[j]] += v[a[j]];</span><br><span class="line">checkmax(mx, cnt[a[j]]);</span><br><span class="line">res[i][belong[j]] = mx;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= r[i]) sum[i][a[j]] += v[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tol; i++)</span><br><span class="line">cnt[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = belong[x], q = belong[y];</span><br><span class="line"><span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">cnt[a[i]] += v[a[i]], checkmax(ans, cnt[a[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">cnt[a[i]] -= v[a[i]];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = res[p + <span class="number">1</span>][q - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (p + <span class="number">1</span> &lt;= q - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= r[p]; i++)</span><br><span class="line"><span class="keyword">if</span> (!vis[a[i]]) </span><br><span class="line">cnt[a[i]] += sum[q - <span class="number">1</span>][a[i]] - sum[p][a[i]], vis[a[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l[q]; i &lt;= y; i++)</span><br><span class="line"><span class="keyword">if</span> (!vis[a[i]])</span><br><span class="line">cnt[a[i]] += sum[q - <span class="number">1</span>][a[i]] - sum[p][a[i]], vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= r[p]; i++) &#123;</span><br><span class="line">cnt[a[i]] += v[a[i]];</span><br><span class="line">checkmax(ans, cnt[a[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l[q]; i &lt;= y; i++) &#123;</span><br><span class="line">cnt[a[i]] += v[a[i]];</span><br><span class="line">checkmax(ans, cnt[a[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= r[p]; i++) &#123;</span><br><span class="line">cnt[a[i]] = <span class="number">0</span>;</span><br><span class="line">vis[a[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l[q]; i &lt;= y; i++) &#123;</span><br><span class="line">cnt[a[i]] = <span class="number">0</span>;</span><br><span class="line">vis[a[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(a[i]), v[i] = a[i];</span><br><span class="line">sort(v + <span class="number">1</span>, v + <span class="number">1</span> + n);</span><br><span class="line">tol = unique(v + <span class="number">1</span>, v + <span class="number">1</span> + n) - v - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">a[i] = lower_bound(v + <span class="number">1</span>, v + <span class="number">1</span> + tol, a[i]) - v;</span><br><span class="line">build();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l, r; q--; ) &#123;</span><br><span class="line">read(l), read(r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;4241-历史研究&quot;&gt;&lt;a href=&quot;#4241-历史研究&quot; class=&quot;headerlink&quot; title=&quot;   4241: 历史研究 &quot;&gt;&lt;/a&gt;&lt;center&gt;  &lt;font color = blue&gt; 4241: 历史研究 &lt;/center&gt;&lt;/h1&gt;&lt;center&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/submitpage.php?id=4241&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Submit]&lt;/a&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4241&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Statics]&lt;/a&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/bbs.php?id=2286&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Discuss]&lt;/a&gt;&lt;/center&gt;


&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;font color = blue&gt;Description&lt;/h2&gt;&lt;p&gt;IOI国历史研究的第一人——JOI教授，最近获得了一份被认为是古代IOI国的住民写下的日记。JOI教授为了通过这份日记来研究古代IOI国的生活，开始着手调查日记中记载的事件。&lt;br&gt;日记中记录了连续N天发生的时间，大约每天发生一件。&lt;br&gt;事件有种类之分。第 $i$ 天($1 \leq i \leq N$)发生的事件的种类用一个整数 $X_i$ 表示，$X_i$ 越大，事件的规模就越大。&lt;br&gt;JOI教授决定用如下的方法分析这些日记：&lt;br&gt;    1.选择日记中连续的一些天作为分析的时间段&lt;br&gt;    2.事件种类t的重要度为 t*(这段时间内重要度为t的事件数)&lt;br&gt;    3.计算出所有事件种类的重要度，输出其中的最大值&lt;br&gt;现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="分块" scheme="http://xzt220.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4403: 序列统计</title>
    <link href="http://xzt220.github.io/2019/09/22/BZOJ4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1/"/>
    <id>http://xzt220.github.io/2019/09/22/BZOJ4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1/</id>
    <published>2019-09-22T11:30:43.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4403-序列统计"><a href="#4403-序列统计" class="headerlink" title="   4403: 序列统计 "></a><center>  <font color = blue> 4403: 序列统计 </center></h1><center>Time Limit: 3 Sec  Memory Limit: 128 MB</center><center>Submit: 1716  Solved: 781</center><center><a href="https://www.lydsy.com/JudgeOnline/submitpage.php?id=4403" target="_blank" rel="noopener">[Submit]</a><a href="https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4403" target="_blank" rel="noopener">[Statics]</a><a href="https://www.lydsy.com/JudgeOnline/bbs.php?id=2286" target="_blank" rel="noopener">[Discuss]</a></center><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a><font color = blue>Description</h2><p>给定三个正整数 $N$ 、 $L$ 和 $R$ ，统计长度在 $1$ 到 $N$ 之间，元素大小都在 $L$ 到 $R$ 之间的单调不降序列的数量。输出答案对$10^6+3$取模的结果。</p><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><font color = blue>Input</h2><p>输入第一行包含一个整数 $T$ ，表示数据组数。<br>第 $2$ 到第 $T+1$ 行每行包含三个整数 $N$、 $L$ 和 $R$ ，$N$ 、$L$ 和 $R$ 的意义如题所述。<br>$1 \leq N,L,R \leq 10^9$，$1 \leq T \leq 100$，输入数据保证 $L \leq R$。</p><h2 id="Output"><a href="#Output" class="headerlink" title=" Output"></a><font color = blue> Output</h2><p>输出包含 $T$ 行，每行有一个数字，表示你所求出的答案对 $10^6+3$ 取模的结果。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a><font color = blue>Sample Input</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a><font color = blue>Sample Output</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【样例说明】满足条件的2个序列为[4]和[5]。</span></span><br></pre></td></tr></table></figure><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a><font color = blue>HINT</h2><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a><font color = blue>Source</h2><p><a href="https://www.lydsy.com/JudgeOnline/problemset.php?search=By%20yts1999" target="_blank" rel="noopener">[By yts1999]</a></p><center><a href="https://www.lydsy.com/JudgeOnline/submitpage.php?id=4403" target="_blank" rel="noopener">[Submit]</a><a href="https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4403" target="_blank" rel="noopener">[Statics]</a><a href="https://www.lydsy.com/JudgeOnline/bbs.php?id=2286" target="_blank" rel="noopener">[Discuss]</a></center><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><font color = blue>Solution</h2><p>一个单调不减的序列，如果在每个位置取的数都加上对应位置的值，这样就是严格单调递增的了。<br>如果 [1, 1, 2, 2, 3]就会变成 [2, 3, 5, 6, 8]<br>就相当于在某个值域里取一些不重复的数了，具体这个值域就是[L + 1 , R + n]。<br>但其实此时跟值域具体的值无关了，只跟值域的长度有关。<br>值域长度为 $n + R - L$ , 那么取长度为 $n$ 的取法就为 $C ^{n} <em>{n + R - L}$<br>答案为$\sum ^{n} </em>{i = 1} C <em>{R - L + i} ^{i}$<br>设 $ m = R - L $<br>$ \sum ^{n} </em>{i = 0} C <em>{m + i} ^{i} = C </em>{m + n + 1} ^{n} $<br>所以答案就是 $ C _{m + n + 1} ^ {n} - 1 $<br>再用一下Lucas定理就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = MOD - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = <span class="number">1L</span>L * ans * a % MOD;</span><br><span class="line">a = <span class="number">1L</span>L * a * a % MOD;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1L</span>L * fac[n] * inv[m] * inv[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> m ? <span class="number">1L</span>L * Lucas(n / MOD, m / MOD) * C(n % MOD, m % MOD) % MOD : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += MOD;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= MOD) a -= MOD;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = fac[<span class="number">0</span>] = <span class="number">1</span>; i &lt; MOD; i++) </span><br><span class="line">fac[i] = <span class="number">1L</span>L * i * fac[i - <span class="number">1</span>] % MOD;</span><br><span class="line">inv[MOD - <span class="number">1</span>] = qp(fac[MOD - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MOD - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">inv[i] = <span class="number">1L</span>L * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> n, l, r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, M(Lucas(n + (r - l + <span class="number">1</span>), r - l + <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;4403-序列统计&quot;&gt;&lt;a href=&quot;#4403-序列统计&quot; class=&quot;headerlink&quot; title=&quot;   4403: 序列统计 &quot;&gt;&lt;/a&gt;&lt;center&gt;  &lt;font color = blue&gt; 4403: 序列统计 &lt;/center&gt;&lt;/h1&gt;&lt;center&gt;Time Limit: 3 Sec  Memory Limit: 128 MB&lt;/center&gt;
&lt;center&gt;Submit: 1716  Solved: 781&lt;/center&gt;
&lt;center&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/submitpage.php?id=4403&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Submit]&lt;/a&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problemstatus.php?id=4403&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Statics]&lt;/a&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/bbs.php?id=2286&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Discuss]&lt;/a&gt;&lt;/center&gt;

&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;font color = blue&gt;Description&lt;/h2&gt;&lt;p&gt;给定三个正整数 $N$ 、 $L$ 和 $R$ ，统计长度在 $1$ 到 $N$ 之间，元素大小都在 $L$ 到 $R$ 之间的单调不降序列的数量。输出答案对$10^6+3$取模的结果。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Lucas定理" scheme="http://xzt220.github.io/tags/Lucas%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>51nod 1814 Clarke and string</title>
    <link href="http://xzt220.github.io/2019/09/17/51nod-1814-Clarke-and-string/"/>
    <id>http://xzt220.github.io/2019/09/17/51nod-1814-Clarke-and-string/</id>
    <published>2019-09-17T13:35:50.000Z</published>
    <updated>2020-07-31T03:08:22.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1814-Clarke-and-string"><a href="#1814-Clarke-and-string" class="headerlink" title="1814 Clarke and string"></a><center>1814 Clarke and string</center></h1><center>2.0 秒 / 262,144.0 KB / 160 分 / <a href="http://www.51nod.com/Challenge/ProblemList.html#level=7&isAsc=false" target="_blank" rel="noopener">[6级题]</a> </center><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>克拉克是一名人格分裂患者.有一天克拉克分裂成 $n$ 个人.<br>每个克拉克手里有一个由小写字母组成字符串 $a<em>i$.<br>克拉克们还有 $q$ 次询问,第 $i$ 次询问,克拉克们想知道有多少个回文串同时出现在 $a</em>{x<em>i}$ 和 $a</em>{y_i}$ 中.<br>一个字符串称为回文串当且仅当这个串前后反转后与这个串相同.</p><a id="more"></a><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行是一个整数 $n$ ($1 \leq n \leq 100000$).<br>接下来 $n$ 行,第 $i$ 行为一个非空字符串$a_i$($1 ≤ \sum|a_i| \leq 100000$).<br>接下来是一行一个整数 $q$ ($1 \leq q \leq 100000$).<br>接下来 $q$ 行,第 $i$ 行有两个非负整数 $A$ , $B$ , 真正的询问为 $x_i$ = $A$ xor ans($i$-1), $y_i$ = $B$ xor ans($i$-1), ans($i$) 表示第 $i$ 次询问得到的答案,其中 ans($0$) = $0$.保证 $1 \leq x_i, y_i \leq n$.</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>一个询问输出一行一个整数,表示答案.</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">aba</span><br><span class="line">aaa</span><br><span class="line">1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直接想最暴力的做法就是正解了。<br>每次询问都把两个串的回文树建出来，然后再两棵树上同时dfs，经过相同的节点答案就加一。遇到一个不存在的就退出。<br>再把询问记忆化一下就OK了。<br>复杂度是 $O(n \sqrt n)$<br>因为每次dfs的复杂度跟短的串的长度有关。<br>自己写给写T了。学习了下优秀写法。多开一个数组表示next是不是当前的next的。这样就不用每次都清数组了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[N], fail[N], len[N];</span><br><span class="line">    pii ne[N][sz];</span><br><span class="line">    <span class="keyword">int</span> n, tol, last, cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = last = <span class="number">0</span>;</span><br><span class="line">        tol = <span class="number">1</span>;</span><br><span class="line">        s[<span class="number">0</span>] = len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s[n - len[x] - <span class="number">1</span>] != s[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        s[++n] = c;</span><br><span class="line">        <span class="keyword">int</span> cur = getid(last);</span><br><span class="line">        <span class="keyword">if</span> (ne[cur][c].se != cnt) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = getid(fail[cur]);</span><br><span class="line">            fail[++tol] = ne[k][c].se == cnt ? ne[k][c].fi : <span class="number">0</span>;</span><br><span class="line">            ne[cur][c] = pii(tol, cnt); len[tol] = len[cur] + <span class="number">2</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        last = ne[cur][c].fi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pam[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; s[N];</span><br><span class="line"><span class="built_in">map</span>&lt;pii, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pam[<span class="number">0</span>].ne[u][i].se == pam[<span class="number">0</span>].cnt &amp;&amp; pam[<span class="number">1</span>].ne[v][i].se == pam[<span class="number">1</span>].cnt) &#123;</span><br><span class="line">ans++;</span><br><span class="line">dfs(pam[<span class="number">0</span>].ne[u][i].fi, pam[<span class="number">1</span>].ne[v][i].fi);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">s[i].push_back(str[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">a ^= ans, b ^= ans;</span><br><span class="line"><span class="keyword">if</span> (s[a].size() &gt; s[b].size()) swap(a, b);</span><br><span class="line"><span class="keyword">if</span> (mp.count(pii(a, b))) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mp[pii(a, b)]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">pam[<span class="number">0</span>].init(), pam[<span class="number">1</span>].init();</span><br><span class="line"><span class="keyword">int</span> len = s[a].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">pam[<span class="number">0</span>].extend(s[a][i] - <span class="string">'a'</span>);</span><br><span class="line">len = s[b].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">pam[<span class="number">1</span>].extend(s[b][i] - <span class="string">'a'</span>);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>); dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mp[pii(a, b)] = ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1814-Clarke-and-string&quot;&gt;&lt;a href=&quot;#1814-Clarke-and-string&quot; class=&quot;headerlink&quot; title=&quot;1814 Clarke and string&quot;&gt;&lt;/a&gt;&lt;center&gt;1814 Clarke and string&lt;/center&gt;&lt;/h1&gt;&lt;center&gt;2.0 秒 / 262,144.0 KB / 160 分 / &lt;a href=&quot;http://www.51nod.com/Challenge/ProblemList.html#level=7&amp;isAsc=false&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[6级题]&lt;/a&gt; &lt;/center&gt;

&lt;h2 id=&quot;Statement&quot;&gt;&lt;a href=&quot;#Statement&quot; class=&quot;headerlink&quot; title=&quot;Statement&quot;&gt;&lt;/a&gt;Statement&lt;/h2&gt;&lt;p&gt;克拉克是一名人格分裂患者.有一天克拉克分裂成 $n$ 个人.&lt;br&gt;每个克拉克手里有一个由小写字母组成字符串 $a&lt;em&gt;i$.&lt;br&gt;克拉克们还有 $q$ 次询问,第 $i$ 次询问,克拉克们想知道有多少个回文串同时出现在 $a&lt;/em&gt;{x&lt;em&gt;i}$ 和 $a&lt;/em&gt;{y_i}$ 中.&lt;br&gt;一个字符串称为回文串当且仅当这个串前后反转后与这个串相同.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="回文树" scheme="http://xzt220.github.io/tags/%E5%9B%9E%E6%96%87%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>hihocoder 全图传送</title>
    <link href="http://xzt220.github.io/2019/09/17/hihocoder-%E5%85%A8%E5%9B%BE%E4%BC%A0%E9%80%81/"/>
    <id>http://xzt220.github.io/2019/09/17/hihocoder-%E5%85%A8%E5%9B%BE%E4%BC%A0%E9%80%81/</id>
    <published>2019-09-16T16:25:18.000Z</published>
    <updated>2020-07-31T03:08:22.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1065-全图传送"><a href="#1065-全图传送" class="headerlink" title="1065 : 全图传送"></a>1065 : 全图传送</h1><p>时间限制:30000ms</p><p>单点时限:3000ms</p><p>内存限制:256MB</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>先知法里奥是 Dota 系列中的一个英雄。机动性强，推塔能力一流，打钱速度快，传送技能使先知可以全地图支援。在后期比拼中通过强大的兵线控制能力使得对方的兵线一直难以过河，并具有一定的后期 DPS 能力。</p><p>我们今天要考虑的是传送技能。假设战场是一个树形区域，每个节点有一个权值 $v_i$。当你传送到某个点 $u$ 时，可以支援距离点 $u$ 半径 $r$ 以内的所有节点。请对于下列询问”$u$ $r$”, 回答以 $u$ 节点为中心，半径 $r$ 以内的节点中，权值最大的节点的编号是多少。如果有多个节点，返回编号最小的。</p><a id="more"></a><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行包含一个整数 $n$ ($1 \leq n \leq 10^5$)，表示节点总数。</p><p>接下来的一行，包含 $n$ 个数字，表示每个节点的权值 $v_i$ ($1 \leq v_i \leq 10^9$)。 接下来的 $n-1$ 行，每行三个整数 ($a_i$, $b_i$, $w_i$)，表示一条连接 $a_i$, $b_i$ 节点的边，边长为 $w_i$($1 \leq a_i, b_i \leq n, 1 \leq w_i \leq 10^4$)。</p><p>接下来的一行包含一个整数 $q$，表示询问总数（$1 \leq q \leq 10^5$）。 接下来 $q$ 行，每行包含两个整数 $u$, $r$($1 \leq u \leq n, 0 \leq r \leq 10^9$)，表示询问以 $u$ 节点为中心，半径 $r$ 以内的节点中，权值最大的节点的编号是多少。如果有多解返回编号最小的。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每组询问，输出一行表示对应答案。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>如果只有单组询问就是水题。多组询问就不能直接在线做了。考虑离线。</p><p>点分治，把当前重心到未被处理过的子树的距离放进一个数组，按距离从小到大排序。排完序后把这些节点替换成当前前缀权值最大的节点。因为如果到这个节点的距离为$r$，那么小于$r$的也能到达，所以取前缀max没有错。</p><p>然后对询问的距离二分一下就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, val[N], sz[N], maxsz[N], totsz, root;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QUE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, dis;</span><br><span class="line">    QUE(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> dis = <span class="number">0</span>): u(u), dis(dis) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> QUE&amp; t) <span class="keyword">const</span> &#123; <span class="keyword">return</span> dis &lt; t.dis; &#125;</span><br><span class="line">&#125; que[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> ne[N], head[N], cnt, to[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>; maxsz[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p: G[u]) &#123;</span><br><span class="line"><span class="keyword">int</span> v = p.se;</span><br><span class="line"><span class="keyword">if</span> (vis[v] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">getroot(v, u);</span><br><span class="line">sz[u] += sz[v];</span><br><span class="line">maxsz[u] = max(maxsz[u], sz[v]);</span><br><span class="line">&#125;</span><br><span class="line">maxsz[u] = max(maxsz[u], totsz - sz[u]);</span><br><span class="line"><span class="keyword">if</span> (maxsz[u] &lt; maxsz[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QUE temp[N];</span><br><span class="line"><span class="keyword">int</span> tol, x[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dep, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">temp[++tol] = QUE(u, dep);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p: G[u]) &#123;</span><br><span class="line"><span class="keyword">int</span> v = p.se;</span><br><span class="line"><span class="keyword">if</span> (vis[v] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v, dep + p.fi, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(temp + <span class="number">1</span>, temp + <span class="number">1</span> + tol);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tol; i++) &#123;</span><br><span class="line">x[i] = temp[i].u;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (val[temp[i].u] &lt; val[temp[i - <span class="number">1</span>].u] || (val[temp[i].u] == val[temp[i - <span class="number">1</span>].u] &amp;&amp; temp[i].u &gt; temp[i - <span class="number">1</span>].u))</span><br><span class="line">temp[i].u = temp[i - <span class="number">1</span>].u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tol; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[x[i]]; j; j = ne[j]) &#123;</span><br><span class="line">QUE q = que[j];</span><br><span class="line"><span class="keyword">if</span> (q.dis &lt; temp[i].dis) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> pos = upper_bound(temp + <span class="number">1</span>, temp + <span class="number">1</span> + tol, QUE(<span class="number">0</span>, q.dis - temp[i].dis)) - temp;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= tol &amp;&amp; q.dis - temp[i].dis &gt;= temp[pos].dis) pos++;</span><br><span class="line">pos--;</span><br><span class="line"><span class="keyword">if</span> (val[ans[j]] &lt; val[temp[pos].u] || (val[ans[j]] == val[temp[pos].u] &amp;&amp; ans[j] &gt; temp[pos].u)) </span><br><span class="line">ans[j] = temp[pos].u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">tol = <span class="number">0</span>;</span><br><span class="line">dfs(u, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">cal();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p: G[u]) &#123;</span><br><span class="line"><span class="keyword">int</span> v = p.se;</span><br><span class="line"><span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">totsz = sz[v];</span><br><span class="line">root = <span class="number">0</span>;</span><br><span class="line">getroot(v, u);</span><br><span class="line">solve(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">G[u].pb(pii(w, v));</span><br><span class="line">G[v].pb(pii(w, u));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;que[i].u, &amp;que[i].dis);</span><br><span class="line">ne[++cnt] = head[que[i].u];</span><br><span class="line">head[que[i].u] = cnt;</span><br><span class="line">ans[i] = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxsz[root = <span class="number">0</span>] = n;</span><br><span class="line">totsz = n;</span><br><span class="line">getroot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">solve(root);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1065-全图传送&quot;&gt;&lt;a href=&quot;#1065-全图传送&quot; class=&quot;headerlink&quot; title=&quot;1065 : 全图传送&quot;&gt;&lt;/a&gt;1065 : 全图传送&lt;/h1&gt;&lt;p&gt;时间限制:30000ms&lt;/p&gt;
&lt;p&gt;单点时限:3000ms&lt;/p&gt;
&lt;p&gt;内存限制:256MB&lt;/p&gt;
&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;先知法里奥是 Dota 系列中的一个英雄。机动性强，推塔能力一流，打钱速度快，传送技能使先知可以全地图支援。在后期比拼中通过强大的兵线控制能力使得对方的兵线一直难以过河，并具有一定的后期 DPS 能力。&lt;/p&gt;
&lt;p&gt;我们今天要考虑的是传送技能。假设战场是一个树形区域，每个节点有一个权值 $v_i$。当你传送到某个点 $u$ 时，可以支援距离点 $u$ 半径 $r$ 以内的所有节点。请对于下列询问”$u$ $r$”, 回答以 $u$ 节点为中心，半径 $r$ 以内的节点中，权值最大的节点的编号是多少。如果有多个节点，返回编号最小的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="点分治" scheme="http://xzt220.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
</feed>
